<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>liu_zhou的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liu-zhou-l.github.io/"/>
  <updated>2023-09-21T08:20:28.000Z</updated>
  <id>https://liu-zhou-l.github.io/</id>
  
  <author>
    <name>liu_zhou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Minecraft启动器制作（C++）</title>
    <link href="https://liu-zhou-l.github.io/posts/f5e17e7b/"/>
    <id>https://liu-zhou-l.github.io/posts/f5e17e7b/</id>
    <published>2023-02-19T07:43:07.000Z</published>
    <updated>2023-09-21T08:20:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>获取Java路径</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT <span class="title">GetJavaHomePathFromRegedit</span><span class="params">(<span class="keyword">wchar_t</span>* retwstr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">wchar_t</span> str[MAX_PATH + <span class="number">1</span>];</span><br><span class="line">INT flag = GetStrFromRegedit(<span class="string">L"SOFTWARE\\JavaSoft\\Java Runtime Environment\\"</span>, <span class="string">L"CurrentVersion"</span>, str);</span><br><span class="line">wprintf(<span class="string">L"%ws\n"</span>, str);</span><br><span class="line"></span><br><span class="line">WCHAR keyjp[MAX_PATH + <span class="number">1</span>] = <span class="string">L"\0"</span>;</span><br><span class="line">swprintf_s(keyjp, MAX_PATH, <span class="string">L"%ws%ws"</span>, <span class="string">L"SOFTWARE\\JavaSoft\\Java Runtime Environment\\"</span>, str);</span><br><span class="line">wprintf(<span class="string">L"%ws\n"</span>, keyjp);</span><br><span class="line">flag = GetStrFromRegedit(keyjp, <span class="string">L"JavaHome"</span>, str);</span><br><span class="line">wprintf(<span class="string">L"%ws\n"</span>, str);</span><br><span class="line">swprintf_s(retwstr, MAX_PATH, <span class="string">L"%ws%ws"</span>, str, <span class="string">L"\\bin\\java.exe"</span>);</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INT <span class="title">GetStrFromRegedit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">wchar_t</span>* hkey, <span class="keyword">const</span> <span class="keyword">wchar_t</span>* childkey, <span class="keyword">wchar_t</span>* str)</span> </span>&#123;</span><br><span class="line">HKEY retKey;</span><br><span class="line">BYTE retKeyVal[MAX_PATH + <span class="number">1</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">DWORD nSize = MAX_PATH + <span class="number">1</span>;</span><br><span class="line">LONG ret = RegOpenKeyEx(HKEY_LOCAL_MACHINE, hkey, <span class="number">0</span>, KEY_QUERY_VALUE | KEY_READ, &amp;retKey);</span><br><span class="line"><span class="comment">//记得加KEY_READ来读取多级子键</span></span><br><span class="line"><span class="keyword">if</span> (ret != ERROR_SUCCESS) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">ret = RegQueryValueEx(retKey, childkey, <span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPBYTE)retKeyVal, &amp;nSize);</span><br><span class="line">RegCloseKey(retKey);</span><br><span class="line"><span class="keyword">if</span> (ret != ERROR_SUCCESS) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">wchar_t</span> TEMPSTR[MAX_PATH + <span class="number">1</span>] = <span class="string">L"\0"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">int</span>(nSize); i += <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (retKeyVal[i + <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">TEMPSTR[i] = retKeyVal[i];</span><br><span class="line"><span class="keyword">if</span> (retKeyVal[i] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">int</span>(nSize); i += <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (retKeyVal[i + <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">*(str + sum) = retKeyVal[i];</span><br><span class="line">sum++;</span><br><span class="line"><span class="keyword">if</span> (retKeyVal[i] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;获取Java路径&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>极域脱控破解分析+代码实现（杀死和重启，挂起和恢复，解除全屏按钮限制，获取极域安装路径，极域密码破解）</title>
    <link href="https://liu-zhou-l.github.io/posts/c117c5fc/"/>
    <id>https://liu-zhou-l.github.io/posts/c117c5fc/</id>
    <published>2023-02-19T07:42:36.000Z</published>
    <updated>2023-09-21T08:20:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>免责声明：以下内容仅供学习使用</p><p>本文的工具成品下载见github<a href="https://github.com/liu-zhou-L/mythwarehelper" target="_blank" rel="noopener">mythwarehelper</a>仓库，附加资源也在内<br>已完成功能：杀死极域，获取极域安装路径，从注册表破解极域密码，重启极域，挂起极域，恢复极域，解除极域全屏窗口限制</p></blockquote><h2 id="搜索极域进程"><a href="#搜索极域进程" class="headerlink" title="搜索极域进程"></a>搜索极域进程</h2><h3 id="极域主进程"><a href="#极域主进程" class="headerlink" title="极域主进程"></a>极域主进程</h3><p>极域的进程由<code>StudentMain.exe</code>启动，因此，只需要使用<code>CreateToolhelp32Snapshot</code>创建快照，遍历所有进程的所有模块，找到其中可执行文件为<code>StudentMain.exe</code>那一个进程即可。</p><p>以下是代码实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Jiyu</span> &#123;</span></span><br><span class="line">DWORD id;</span><br><span class="line"><span class="keyword">char</span> filepath[<span class="number">260</span>];</span><br><span class="line">BOOL flag;</span><br><span class="line">&#125; jiyu;</span><br><span class="line"></span><br><span class="line"><span class="function">Jiyu <span class="title">ModuleIsAble</span><span class="params">(DWORD ProcessPid, LPCSTR Modulename)</span> </span>&#123;</span><br><span class="line">Jiyu tj;</span><br><span class="line"><span class="keyword">if</span> (Modulename[<span class="number">0</span>] == <span class="string">'\0'</span>) &#123;</span><br><span class="line">tj.flag = FALSE;</span><br><span class="line"><span class="keyword">return</span> tj;</span><br><span class="line">&#125;</span><br><span class="line">MODULEENTRY32 me;</span><br><span class="line">me.dwSize = <span class="keyword">sizeof</span>(MODULEENTRY32);</span><br><span class="line">HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, ProcessPid);</span><br><span class="line"><span class="keyword">if</span> (Module32First(hSnapshot, &amp;me)) &#123;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">//printf("thread - %s\n", me.szModule);</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(Modulename, me.szModule)) &#123;</span><br><span class="line">CloseHandle(hSnapshot);</span><br><span class="line"><span class="built_in">strcpy</span>(tj.filepath, me.szExePath);</span><br><span class="line">tj.id = ProcessPid;</span><br><span class="line">tj.flag = TRUE;</span><br><span class="line"><span class="keyword">return</span> tj;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (Module32Next(hSnapshot, &amp;me));</span><br><span class="line">&#125;</span><br><span class="line">CloseHandle(hSnapshot);</span><br><span class="line">tj.flag = FALSE;</span><br><span class="line"><span class="keyword">return</span> tj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Jiyu <span class="title">GetProcessPidFromFilename</span><span class="params">(LPCSTR Filename)</span> </span>&#123;</span><br><span class="line">Jiyu tj;</span><br><span class="line"><span class="keyword">if</span> (Filename[<span class="number">0</span>] == <span class="string">'\0'</span>) &#123;</span><br><span class="line">tj.flag = FALSE;</span><br><span class="line"><span class="keyword">return</span> tj;</span><br><span class="line">&#125;</span><br><span class="line">PROCESSENTRY32 te;</span><br><span class="line">te.dwSize = <span class="keyword">sizeof</span>(PROCESSENTRY32);</span><br><span class="line">HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (Process32First(hSnapshot, &amp;te)) &#123;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">HANDLE temphandle = OpenProcess(PROCESS_ALL_ACCESS, <span class="literal">false</span>, te.th32ProcessID);</span><br><span class="line"><span class="comment">//printf("%ld\n", te.th32ProcessID);</span></span><br><span class="line">tj = ModuleIsAble(te.th32ProcessID, Filename);</span><br><span class="line"><span class="keyword">if</span> (tj.flag == TRUE) &#123;</span><br><span class="line">CloseHandle(hSnapshot);</span><br><span class="line"><span class="keyword">return</span> tj;</span><br><span class="line">&#125;</span><br><span class="line">CloseHandle(temphandle);</span><br><span class="line">&#125; <span class="keyword">while</span> (Process32Next(hSnapshot, &amp;te));</span><br><span class="line">&#125;</span><br><span class="line">tj.flag = FALSE;</span><br><span class="line"><span class="keyword">return</span> tj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="极域广播窗口"><a href="#极域广播窗口" class="headerlink" title="极域广播窗口"></a>极域广播窗口</h3><p>极域广播窗口是一个窗体，窗体标题固定为“屏幕广播”，因此可以直接使用<code>FindWindow(LPCSTR lpClassName,LPCSTR lpWindowName)</code>函数来获取进程句柄，在第二个参数处填入窗体名即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HWND Class = FindWindowW(<span class="literal">NULL</span>, <span class="string">L"屏幕广播"</span>);<span class="comment">//Class为获取到的窗口句柄</span></span><br><span class="line"><span class="keyword">if</span> (Class != <span class="literal">NULL</span>) &#123;<span class="comment">//广播窗口存在</span></span><br><span class="line">GetWindowThreadProcessId(Class, &amp;pid);<span class="comment">//由窗口句柄获取pid</span></span><br><span class="line">HANDlE ClassHandle = OpenThread(THREAD_ALL_ACCESS, <span class="literal">false</span>, GetMainThreadFromId(pid));<span class="comment">//由pid获取可操控窗口的句柄</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//广播窗口不存在</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取极域安装路径（用来在杀死极域后重启）"><a href="#获取极域安装路径（用来在杀死极域后重启）" class="headerlink" title="获取极域安装路径（用来在杀死极域后重启）"></a>获取极域安装路径（用来在杀死极域后重启）</h2><p>极域安装路径存储在系统注册表<code>SOFTWARE\\WOW6432Node\\TopDomain\\e-Learning Class Standard\\1.00\\TargetDirectory</code></p><p>以下为获取函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UINT <span class="title">GetMythwarePathFromRegedit</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">HKEY retKey;</span><br><span class="line"><span class="keyword">char</span> tstr[<span class="number">200</span>] = <span class="string">"SOFTWARE\\WOW6432Node\\TopDomain\\e-Learning Class Standard\\1.00"</span>;</span><br><span class="line">DWORD dwDisposition = REG_OPENED_EXISTING_KEY;</span><br><span class="line">LONG ret = RegCreateKeyEx(HKEY_LOCAL_MACHINE, tstr, <span class="number">0</span>, <span class="literal">NULL</span>, REG_OPTION_NON_VOLATILE, KEY_READ, <span class="literal">NULL</span>, &amp;retKey, &amp;dwDisposition);</span><br><span class="line"><span class="keyword">if</span> (ret != ERROR_SUCCESS) &#123;</span><br><span class="line"><span class="comment">//打开注册表失败</span></span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">BYTE tByte[MAX_PATH * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">DWORD nSize = MAX_PATH * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">ret = RegQueryValueEx(retKey, <span class="string">"TargetDirectory"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, tByte, &amp;nSize);</span><br><span class="line"><span class="keyword">if</span> (ret == ERROR_SUCCESS) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">int</span>(nSize); i += <span class="number">1</span>) &#123;</span><br><span class="line">*(str + sum) = tByte[i];</span><br><span class="line"><span class="keyword">if</span> (*(str + sum++) == <span class="string">'\\'</span>) &#123;</span><br><span class="line">*(str + sum++) = <span class="string">'\\'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取极域安装路径成功</span></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取极域安装路径失败</span></span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="杀死极域进程"><a href="#杀死极域进程" class="headerlink" title="杀死极域进程"></a>杀死极域进程</h2><h3 id="taskkill"><a href="#taskkill" class="headerlink" title="taskkill"></a>taskkill</h3><p>在命令行中输入<br><code>taskkill /f /im studentmain.exe</code><br>即可杀死极域进程，但有时候会失效</p><h3 id="ntsd"><a href="#ntsd" class="headerlink" title="ntsd"></a>ntsd</h3><blockquote><p>ntsd是一个用户态进程调试工具，从Windows 2000就开始被附随在System32目录下。它能够结束除System、smss.exe、csrss.exe、lsass.exe及各种rootkit程序外所有的程序。但在Windows Vista及以上版本的Windows中不含ntsd， 必须手动下载至电脑中才可使用。——百度百科</p></blockquote><p>在命令行中输入<br><code>./ntsd.exe -c q -pn studentmain.exe</code><br>即可杀死极域进程，目前博主没有遇到失效的情况</p><p>如需下载ntsd.exe可访问我的<a href="https://github.com/liu-zhou-L/mythwarehelper" target="_blank" rel="noopener">mythwarehelper</a>仓库</p><h2 id="挂起和恢复极域进程"><a href="#挂起和恢复极域进程" class="headerlink" title="挂起和恢复极域进程"></a>挂起和恢复极域进程</h2><p>再不使用外部DLL的情况下，C++没有原生的挂起和回复进程的函数，因此<del>不能白嫖</del>  挂起进程只能自己实现，进程由线程构成，因此如果挂起了一个进程的每一个线程，就相当于是挂起了这个进程。挂起线程可使用<code>SuspendThread</code>，恢复线程可使用<code>ResumeThread</code></p><p>以下是代码实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能:挂起进程中的所有线程</span></span><br><span class="line"><span class="comment">参数1:进程ID</span></span><br><span class="line"><span class="comment">参数2:若为TRUE时对进程中的所有线程调用SuspendThread,挂起线程</span></span><br><span class="line"><span class="comment">      若为FALSE时对进程中的所有线程调用ResumeThread,恢复线程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">SuspendProcess</span><span class="params">(DWORD dwProcessID, BOOL fSuspend)</span> </span>&#123;</span><br><span class="line">HANDLE hSnapshot = CreateToolhelp32Snapshot(</span><br><span class="line">                       TH32CS_SNAPTHREAD, dwProcessID);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hSnapshot != INVALID_HANDLE_VALUE) &#123;</span><br><span class="line"></span><br><span class="line">THREADENTRY32 te = &#123;<span class="keyword">sizeof</span>(te)&#125;;</span><br><span class="line">BOOL fOk = Thread32First(hSnapshot, &amp;te);</span><br><span class="line"><span class="keyword">for</span> (; fOk; fOk = Thread32Next(hSnapshot, &amp;te)) &#123;</span><br><span class="line"><span class="keyword">if</span> (te.th32OwnerProcessID == dwProcessID) &#123;</span><br><span class="line">HANDLE hThread = OpenThread(THREAD_SUSPEND_RESUME, FALSE, te.th32ThreadID);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hThread != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (fSuspend) &#123;</span><br><span class="line">SuspendThread(hThread);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ResumeThread(hThread);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">CloseHandle(hThread);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">CloseHandle(hSnapshot);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解除全屏按钮限制"><a href="#解除全屏按钮限制" class="headerlink" title="解除全屏按钮限制"></a>解除全屏按钮限制</h2><p>极域的广播窗口有一个全屏切换按钮，在强制全屏时会设置为无法使用，变成灰色，Windows的按钮即为控件，交互式控件有两个状态，一个是可用，一个是不可用，可以通过调用<code>EnableWindow</code>函数来设置此类控件的状态，也可以借此设置全屏切换按钮的状态，在老师设置按钮为不可用时，调用此函数设置按钮为可用，就可以自行退出全屏了</p><p>以下是代码实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一个EnumChildWindows函数的回调函数，EnumChildWindows的父窗口句柄为极域的广播窗口句柄</span></span><br><span class="line"><span class="function">BOOL CALLBACK <span class="title">EnumChildWindowsProc</span><span class="params">(HWND hwndChild, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">HMENU hmenu = GetMenu(hwndChild);</span><br><span class="line"><span class="keyword">if</span> (LOWORD(hmenu) == <span class="number">1004</span>) &#123;<span class="comment">//1004为全屏切换按钮的HMENU值</span></span><br><span class="line"><span class="keyword">if</span> (!IsWindowEnabled(hwndChild)) &#123;</span><br><span class="line">EnableWindow(hwndChild, TRUE);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">EnableWindow(hwndChild, FALSE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到这个按钮就跳出遍历</span></span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="破解极域密码"><a href="#破解极域密码" class="headerlink" title="破解极域密码"></a>破解极域密码</h2><p>极域的密码存储在系统注册表<code>SOFTWARE\\TopDomain\\e-Learning Class\\Student</code><br>极域的密码在部分版本中使用明文存储，但新版都是存储的密文<br><a href="https://github.com/MuliMuri/Mythware/blob/master/Test/Program.cs" target="_blank" rel="noopener">解密代码来源</a><br><a href="https://www.bilibili.com/video/BV1wi4y1A7wc" target="_blank" rel="noopener">解密分析视频</a></p><p>以下是破解代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetMythwarePasswordFromRegedit</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">HKEY retKey;</span><br><span class="line">BYTE retKeyVal[MAX_PATH * <span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">DWORD nSize = MAX_PATH * <span class="number">10</span>;</span><br><span class="line">LONG ret = RegOpenKeyEx(HKEY_LOCAL_MACHINE, <span class="string">"SOFTWARE\\TopDomain\\e-Learning Class\\Student"</span>, <span class="number">0</span>, KEY_QUERY_VALUE | KEY_WOW64_32KEY, &amp;retKey);</span><br><span class="line"><span class="keyword">if</span> (ret != ERROR_SUCCESS) &#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">ret = RegQueryValueExA(retKey, <span class="string">"knock1"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPBYTE)retKeyVal, &amp;nSize);</span><br><span class="line">RegCloseKey(retKey);</span><br><span class="line"><span class="keyword">if</span> (ret != ERROR_SUCCESS) &#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">int</span>(nSize); i += <span class="number">4</span>) &#123;</span><br><span class="line">retKeyVal[i + <span class="number">0</span>] = (retKeyVal[i + <span class="number">0</span>] ^ <span class="number">0x50</span> ^ <span class="number">0x45</span>);</span><br><span class="line">retKeyVal[i + <span class="number">1</span>] = (retKeyVal[i + <span class="number">1</span>] ^ <span class="number">0x43</span> ^ <span class="number">0x4c</span>);</span><br><span class="line">retKeyVal[i + <span class="number">2</span>] = (retKeyVal[i + <span class="number">2</span>] ^ <span class="number">0x4c</span> ^ <span class="number">0x43</span>);</span><br><span class="line">retKeyVal[i + <span class="number">3</span>] = (retKeyVal[i + <span class="number">3</span>] ^ <span class="number">0x45</span> ^ <span class="number">0x50</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">int</span>(nSize); i += <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%x "</span>, retKeyVal[i]);</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">8</span> == <span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">int</span>(nSize); i += <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (retKeyVal[i + <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">*(str + sum) = retKeyVal[i];</span><br><span class="line">sum++;</span><br><span class="line"><span class="keyword">if</span> (retKeyVal[i] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;免责声明：以下内容仅供学习使用&lt;/p&gt;
&lt;p&gt;本文的工具成品下载见github&lt;a href=&quot;https://github.com/liu-zhou-L/mythwarehelper&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;mythwarehelper&lt;/a&gt;仓库，附加资源也在内&lt;br&gt;已完成功能：杀死极域，获取极域安装路径，从注册表破解极域密码，重启极域，挂起极域，恢复极域，解除极域全屏窗口限制&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;搜索极域进程&quot;&gt;&lt;a href=&quot;#搜索极域进程&quot; class=&quot;headerlink&quot; title=&quot;搜索极域进程&quot;&gt;&lt;/a&gt;搜索极域进程&lt;/h2&gt;&lt;h3 id=&quot;极域主进程&quot;&gt;&lt;a href=&quot;#极域主进程&quot; class=&quot;headerlink&quot; title=&quot;极域主进程&quot;&gt;&lt;/a&gt;极域主进程&lt;/h3&gt;&lt;p&gt;极域的进程由&lt;code&gt;StudentMain.exe&lt;/code&gt;启动，因此，只需要使用&lt;code&gt;CreateToolhelp32Snapshot&lt;/code&gt;创建快照，遍历所有进程的所有模块，找到其中可执行文件为&lt;code&gt;StudentMain.exe&lt;/code&gt;那一个进程即可。&lt;/p&gt;
&lt;p&gt;以下是代码实现&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>NOIP模拟赛3</title>
    <link href="https://liu-zhou-l.github.io/posts/ad1dd5a1/"/>
    <id>https://liu-zhou-l.github.io/posts/ad1dd5a1/</id>
    <published>2020-07-28T09:40:00.000Z</published>
    <updated>2023-09-21T08:20:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿 +"></a>挖矿 +</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><em>有N名矿工在挖矿。工厂预先给第i名矿工支付了Mi元工资，他每挖一吨矿需要消费Ki元头 余下的钱不足Ki元，他就停止挖矿。他每挖一吨矿，工厂会立即奖励他2元钱。奖励的钱于挖矿的消费。</em></p><p><em>给出矿工的信息，请你计算一下矿工们总共可以挖出多少吨矿，以及哪个矿工挖的矿最多。</em></p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p><em>第1行：1个整数N，表示矿工的人数(1 ≤ N ≤ 70)</em></p><p><em>接下来2N行，每2行描述1名矿工。第1行是一字符串(长度不超过20个字符)，表示矿工的姓名，第2行 2个整数，分别表示Ki(12 ≤ Ki ≤ 400)和Mi(1 ≤ Mi ≤ 10000)</em></p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p><em>第1行：1个整数，表示矿工们总共可以挖出多少吨矿</em></p><p><em>第2行：1个字符串，表示挖矿最多的矿工的姓名。如果多个矿工挖得一样多，输出最靠前的1个人。</em></p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">Caterpie</span><br><span class="line">12 33</span><br><span class="line">Weedle</span><br><span class="line">12 42</span><br><span class="line">Pidgey</span><br><span class="line">12 47</span><br><span class="line">Rattata</span><br><span class="line">25 71</span><br></pre></td></tr></table></figure><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">14</span><br><span class="line">Weedle</span><br></pre></td></tr></table></figure><h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p><em>COCI16-17 2# Go</em></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>模拟求出每一个工人的最大挖矿数，累加并记录最大值即可</p><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">75</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">40</span>];</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> s;</span><br><span class="line">&#125; workers[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, sum = <span class="number">0</span>, maxn = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(node worker)</span> </span>&#123;<span class="comment">//求最大挖矿数的函数</span></span><br><span class="line"><span class="keyword">while</span> (worker.m &gt;= worker.k) &#123;</span><br><span class="line">worker.s++;</span><br><span class="line">worker.m -= worker.k;</span><br><span class="line">worker.m += <span class="number">2</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> worker.s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>, workers[i].name, &amp;workers[i].k, &amp;workers[i].m);</span><br><span class="line">workers[i].s = check(workers[i]);</span><br><span class="line">sum += workers[i].s;</span><br><span class="line"><span class="keyword">if</span> (workers[i].s &gt; workers[maxn].s) &#123;<span class="comment">//记录最大值</span></span><br><span class="line">maxn = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n%s"</span>, sum, workers[maxn].name);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小乘积"><a href="#最小乘积" class="headerlink" title="最小乘积 ++"></a>最小乘积 ++</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p><em>给出0~9这10个数字的个数，放在数组A中。A[0]表示数字0的个数，A[1]表示数字1的个数，…，A[9]表示数字9的个数。</em></p><p><em>你要用这些数字构造整数A和B，A恰好有W1位，B恰好有W2，允许A和B出现前导0。要求数字i在A和 B中出现的次数之和不超过A[i]。</em></p><p><em>数据保证数组A的元素之和至少为W1+W2</em></p><p><em>在所有的合法整数对A、B中，找出它们乘积最小的一对数。</em></p><h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p><em>第1行：10个整数，表示数组A， 0 ≤ A[i] ≤ 20</em></p><p><em>第2行：1个整数，表示W1 1 ≤ W1 ≤ 9</em></p><p><em>第3行：1个整数，表示W2 1 ≤ W2 ≤ 9</em></p><h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p><em>第1行：1个整数，表示A和B的最小乘积</em></p><h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 1 1 2 1 1 0 0 0 0</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3042</span><br></pre></td></tr></table></figure><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>要让乘积尽量小，显然 $ a $ 和 $ b $ 都尽量小。利用贪心的思想，去构造数字 $ a $ 和 $ b $ 。<br>首先，题目设定允许有前导 $ 0 $ ，因此如果有数字 $ 0 $ ，<strong>则尽量安排给位数小的数</strong>(这一点在考试时没想到,丢了48分)，因为如果能够让 $ a $ 或者 $ b $ 成为 $ 0 $ ，则乘积可以达到理论上的最小值： $ 0 $<br>如果数字 $ 0 $ 的个数不能让 $ a $ 或者 $ b $ 变为0，把0全部安排给位数小的数，也比两边分配更优。可以把分配了<br>所有的 $ 0 $ 后剩余的位数当作需要构造的位数。<br>分配了数字 $ 0 $ ，再从小到大考虑其他分配其它的数字。显然，需要的数字的个数是 $ W1+W2 $ .我们先从 $ A $ 数组中从 $ 1 $ 到 $ 9 $ 的顺序把数字逐个存放在另一个数组 $ B $ 中，再轮流从 $ B $ 数组中取出数字填在 $ a $ 和 $ b $ 的各个数<br>位上。<br>当位数小的数填完之后，再把剩余的数字全部填在位数大的数中。</p><h2 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">15</span>], w[<span class="number">5</span>];</span><br><span class="line">ll num = <span class="number">0</span>, num_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> &amp;one, <span class="keyword">int</span> &amp;two)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = one;</span><br><span class="line">one = two;</span><br><span class="line">two = temp;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//freopen("minproduct.in", "r", stdin);</span></span><br><span class="line"><span class="comment">//freopen("minproduct.out", "w", stdout);</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;w[<span class="number">1</span>], &amp;w[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">if</span> (w[<span class="number">1</span>] &lt;= a[<span class="number">0</span>] || w[<span class="number">2</span>] &lt;= a[<span class="number">0</span>]) &#123;<span class="comment">//如果有一个元素可以为零,则直接输出零</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (w[<span class="number">1</span>] &gt; w[<span class="number">2</span>]) Swap(w[<span class="number">1</span>], w[<span class="number">2</span>]);<span class="comment">//把长度小的放在第一个</span></span><br><span class="line"><span class="comment">//printf("%d %d", w[1], w[2]);</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">w[<span class="number">1</span>] -= a[<span class="number">0</span>]; <span class="comment">//!!!--将0全部放入第一个元素中--!!!</span></span><br><span class="line"><span class="keyword">while</span> (w[<span class="number">1</span>] + w[<span class="number">2</span>]) &#123;<span class="comment">//当两者没有都为零时</span></span><br><span class="line"><span class="keyword">while</span> (w[<span class="number">1</span>] + w[<span class="number">2</span>]) &#123;</span><br><span class="line"><span class="keyword">while</span> (a[index] == <span class="number">0</span>) index++;<span class="comment">//如果这一位数字用完了,就换下一个</span></span><br><span class="line"><span class="keyword">if</span> (w[<span class="number">1</span>] != <span class="number">0</span>) &#123;<span class="comment">//第一个元素还可以加时</span></span><br><span class="line">num = num * <span class="number">10</span> + index;<span class="comment">//在末尾增加index</span></span><br><span class="line">w[<span class="number">1</span>]--;<span class="comment">//剩余长度减一</span></span><br><span class="line">a[index]--;当前位置的数量减一</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (a[index] == <span class="number">0</span>) index++;</span><br><span class="line"><span class="keyword">if</span> (w[<span class="number">2</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">num_ = num_ * <span class="number">10</span> + index;</span><br><span class="line">w[<span class="number">2</span>]--;</span><br><span class="line">a[index]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf("%lld %lld\n", num, num_);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>, num * num_);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="回文数组"><a href="#回文数组" class="headerlink" title="回文数组 **"></a>回文数组 **</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p><em>给定有N个整数的数组A，下标从1到N。如果对每一个下标i均满足A[i] =A[N-i+1]，则称数组是回文的。</em></p><p><em>例如，数组A={1,2,3,2,1}就是回文数组。</em></p><p><em>如果数组A不是回文的，可以采用合并两个相邻元素的方法去得到回文数组。注意，每操作一次，数组的元素数量减少1。</em></p><p><em>例如，数组A={1,2,3}不是回文数组，但是通过合并A[1]和A[2]，得到{3,3}就是回文数组了。</em></p><p><em>显然，无论给出怎样的数组元素，最多经过N-1次操作，合并为一个数时，数组A一定是回文数组了。</em></p><p><em>因此，本题一定有解。</em></p><p><em>然而问题来了：对于给定的数组A，最少经过多少次操作，能让A变成回文数组？</em></p><h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p><em>第1行：1个整数N，表示数组A的元素个数</em></p><p><em>第2行：N个空格分开的整数，表示数组A</em></p><h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p><em>第1行：1个整数，表示最少的操作次数</em></p><h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 4 3 2</span><br></pre></td></tr></table></figure><h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p><del>左右横跳之术</del> 很明显,在这道题中因为是累加,较大数是无法变成较小数的,所以肯定是考虑将较小数累加为较大数,而边缘的数肯定不可能与中间的数对称,所以每次只考虑边缘的两个数,不同就累加较小数,直到左右数字相同或左右两个指针相遇</p><h2 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">1</span>, right = n;<span class="comment">//左右指针</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;<span class="comment">//两侧指针没相遇时</span></span><br><span class="line"><span class="keyword">if</span> (a[left] != a[right]) &#123;<span class="comment">//不同时需要改变某一侧的数</span></span><br><span class="line"><span class="keyword">if</span> (a[left] &lt; a[right]) &#123;<span class="comment">//累加较小数</span></span><br><span class="line">left++;</span><br><span class="line">a[left] += a[left - <span class="number">1</span>];</span><br><span class="line">sum++;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[left] &gt; a[right]) &#123;</span><br><span class="line">right--;</span><br><span class="line">a[right] += a[right + <span class="number">1</span>];</span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">//相同则左右指针同时向内收缩</span></span><br><span class="line">left++;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, sum);</span><br><span class="line"><span class="comment">/*puts("");</span></span><br><span class="line"><span class="comment">for(int i = left; i &lt;= right; i++) &#123;</span></span><br><span class="line"><span class="comment">printf("%lld ", a[i]);</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="乌龟"><a href="#乌龟" class="headerlink" title="乌龟 ++++"></a>乌龟 ++++</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p><em>一只乌龟由于智商低下，它只会向左或向右走，不过它会遵循主人小h的指令：F（向前走一步），T（掉头）。</em></p><p><em>现在小h给出一串指令，由于小h有高超的计算能力，他可以马上知道乌龟最后走到哪里。为了难倒小h，他的好朋友小c就说，现在让你修改其中n个指令，使得乌龟移动到离起点最远的地方。（修改是指“T”变成“F”，或“F”变成“T”,可以对同一个指令多次修改）。乌龟一开始在0点</em></p><h2 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h2><p><em>第1行:一个字符串S代表指令</em></p><p><em>接下来一行一个整数n，表示要修改的指令个数</em></p><h2 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h2><p><em>第1行：一个整数，表示乌龟所能移动到的最远距离。</em></p><h2 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FFFTFFF</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>这道题有两种解法,记忆化搜索和动态规划,这里讲解记忆化搜索</p><p>这道题用爆搜是很容易想到的,但超时就和想到一样容易(</p><p>记忆化是一个方法,这里用<code>f[i][j][k][l]</code>表示执行到第<code>i</code>条指令,已经修改了<code>j</code>条指令,距离原点为<code>k</code>(有正负两种情况),当前方向为<code>l</code>(0向左,1向右)的最远距离,函数参数同理</p><p>讨论一下决策方案,最基本的分为当前位置为<code>F</code>和为<code>T</code>两种情况,且分别有改和不改两种</p><p>设当前状态为<code>dfs(now,cnt,sum,fx)</code></p><ul><li>当为<code>T</code>且要改时,则<code>now</code>加一,<code>cnt</code>加一,<code>sum</code>根据<code>fx</code>加一或减一,即<code>dfs(now + 1, cnt + 1, sum + ((fx == 0) ? 1 : -1), fx)</code></li><li>当为<code>T</code>且不改时,则<code>now</code>加一,<code>cnt</code>和<code>sum</code>不变,<code>fx</code>变为相反值,即<code>dfs(now + 1, cnt, sum, (fx == 0) ? 1 : 0)</code></li><li>当为<code>F</code>且要改时,则<code>now</code>加一,<code>cnt</code>加一,<code>sum</code>不变,方向变为相反值,即<code>dfs(now + 1, cnt + 1, sum, (fx == 0) ? 1 : 0)</code></li><li>当为<code>F</code>且不改时,则<code>now</code>加一,<code>cnt</code>加一,<code>sum</code>根据<code>fx</code>加一或减一,即<code>dfs(now + 1, cnt, sum + ((fx == 0) ? 1 : -1), fx)</code></li></ul><p>除以上四种情况以外,也可选择将当前命令改变两次,则<code>cnt</code>加二其它不变,即<code>dfs(now, cnt + 2, sum, fx)</code></p><p>如果<code>now</code>超过<code>s</code>的长加一或<code>cnt</code>超过<code>n</code>,都不符合,执行<code>return</code></p><p><code>f</code>数组为记忆化数组,如果当前情况计算过了,也<code>return</code></p><p>如果<code>now</code>等于<code>s</code>的长加一,且<code>cnt</code>等于<code>n</code>,则此种情况计算完毕,将<code>sum</code>的绝对值与<code>ans</code>比较保存答案并<code>return</code></p><h2 id="AC代码-3"><a href="#AC代码-3" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">105</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, len, ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> f[MAXN][<span class="number">55</span>][MAXN &lt;&lt; <span class="number">1</span>][<span class="number">2</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">char</span> s[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> cnt, <span class="keyword">int</span> sum, <span class="keyword">int</span> fx)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (f[now][cnt][sum][fx]) <span class="keyword">return</span>;</span><br><span class="line">f[now][cnt][sum][fx] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (now &gt; len + <span class="number">1</span> || cnt &gt; n) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (now == len + <span class="number">1</span> &amp;&amp; cnt == n) &#123;</span><br><span class="line">ans = <span class="built_in">std</span>::max(ans, <span class="built_in">abs</span>(sum));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(s[now] == <span class="string">'T'</span>) &#123;</span><br><span class="line">dfs(now + <span class="number">1</span>, cnt + <span class="number">1</span>, sum + ((fx == <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">-1</span>), fx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">dfs(now + <span class="number">1</span>, cnt, sum + ((fx == <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">-1</span>), fx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(s[now] == <span class="string">'F'</span>) &#123;</span><br><span class="line">dfs(now + <span class="number">1</span>, cnt + <span class="number">1</span>, sum, (fx == <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">dfs(now + <span class="number">1</span>, cnt, sum, (fx == <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">dfs(now, cnt + <span class="number">2</span>, sum, fx);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, s + <span class="number">1</span>, &amp;n);</span><br><span class="line">len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//初始为执行到第1条指令,其它均为零</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;挖矿&quot;&gt;&lt;a href=&quot;#挖矿&quot; class=&quot;headerlink&quot; title=&quot;挖矿 +&quot;&gt;&lt;/a&gt;挖矿 +&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;em&gt;有N名矿工在挖矿。工厂预先给第i名矿工支付了Mi元工资，他每挖一吨矿需要消费Ki元头 余下的钱不足Ki元，他就停止挖矿。他每挖一吨矿，工厂会立即奖励他2元钱。奖励的钱于挖矿的消费。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;给出矿工的信息，请你计算一下矿工们总共可以挖出多少吨矿，以及哪个矿工挖的矿最多。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入格式&quot; class=&quot;headerlink&quot; title=&quot;输入格式&quot;&gt;&lt;/a&gt;输入格式&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="模拟" scheme="https://liu-zhou-l.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>NOIP模拟赛2</title>
    <link href="https://liu-zhou-l.github.io/posts/da1ae537/"/>
    <id>https://liu-zhou-l.github.io/posts/da1ae537/</id>
    <published>2020-07-27T13:42:00.000Z</published>
    <updated>2023-09-21T08:20:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符串的展开"><a href="#字符串的展开" class="headerlink" title="字符串的展开"></a>字符串的展开</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.luogu.com.cn/problem/P1098" target="_blank" rel="noopener">luoguP1098</a></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>简单模拟，按照题目要求来一步步实现即可</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">20005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cmd1, cmd2, cmd3, len;</span><br><span class="line"><span class="keyword">char</span> s[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_char</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//判断是否满足字符串展开的条件</span></span><br><span class="line"><span class="keyword">return</span> s[x] == <span class="string">'-'</span> &amp;&amp; s[x - <span class="number">1</span>] &gt;= <span class="string">'a'</span> &amp;&amp; s[x - <span class="number">1</span>] &lt;= <span class="string">'z'</span> &amp;&amp; s[x + <span class="number">1</span>] &gt;= <span class="string">'a'</span> &amp;&amp; s[x + <span class="number">1</span>] &lt;= <span class="string">'z'</span> &amp;&amp; s[x - <span class="number">1</span>] &lt; s[x + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_num</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//判断是否满足数字展开的条件</span></span><br><span class="line"><span class="keyword">return</span> s[x] == <span class="string">'-'</span> &amp;&amp; s[x - <span class="number">1</span>] &gt;= <span class="string">'0'</span> &amp;&amp; s[x - <span class="number">1</span>] &lt;= <span class="string">'9'</span> &amp;&amp; s[x + <span class="number">1</span>] &gt;= <span class="string">'0'</span> &amp;&amp; s[x + <span class="number">1</span>] &lt;= <span class="string">'9'</span> &amp;&amp; s[x - <span class="number">1</span>] &lt; s[x + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//freopen("expand.in", "r", stdin);</span></span><br><span class="line"><span class="comment">//freopen("expand.out", "w", stdout);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;cmd1, &amp;cmd2, &amp;cmd3);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">putchar</span>(s[<span class="number">1</span>]);<span class="comment">//第一个和最后一个元素单独处理</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; len; i++) &#123;<span class="comment">//核心代码，按照题意来即可</span></span><br><span class="line"><span class="keyword">if</span> (check_char(i)) &#123;<span class="comment">//字符展开的情况</span></span><br><span class="line"><span class="keyword">if</span> (cmd3 == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = s[i - <span class="number">1</span>] + <span class="number">1</span>; j &lt;= s[i + <span class="number">1</span>] - <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= cmd2; k++) &#123;</span><br><span class="line"><span class="keyword">if</span> (cmd1 == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//printf("%c", j);</span></span><br><span class="line"><span class="built_in">putchar</span>(j);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd1 == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="comment">//printf("%c", j - 32);</span></span><br><span class="line"><span class="built_in">putchar</span>(j - (<span class="string">'a'</span> - <span class="string">'A'</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd1 == <span class="number">3</span>) &#123;</span><br><span class="line"><span class="comment">//printf("*");</span></span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">'*'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd3 == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = s[i + <span class="number">1</span>] - <span class="number">1</span>; j &gt;= s[i - <span class="number">1</span>] + <span class="number">1</span>; j--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= cmd2; k++) &#123;</span><br><span class="line"><span class="keyword">if</span> (cmd1 == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//printf("%c", j);</span></span><br><span class="line"><span class="built_in">putchar</span>(j);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd1 == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="comment">//printf("%c", j - 32);</span></span><br><span class="line"><span class="built_in">putchar</span>(j - (<span class="string">'a'</span> - <span class="string">'A'</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd1 == <span class="number">3</span>) &#123;</span><br><span class="line"><span class="comment">//printf("*");</span></span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">'*'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (check_num(i)) &#123;<span class="comment">//数字展开的情况</span></span><br><span class="line"><span class="keyword">if</span> (cmd3 == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = s[i - <span class="number">1</span>] + <span class="number">1</span>; j &lt;= s[i + <span class="number">1</span>] - <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= cmd2; k++) &#123;</span><br><span class="line"><span class="keyword">if</span> (cmd1 == <span class="number">3</span>) &#123;</span><br><span class="line"><span class="comment">//printf("*");</span></span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">'*'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//printf("%c", j);</span></span><br><span class="line"><span class="built_in">putchar</span>(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd3 == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = s[i + <span class="number">1</span>] - <span class="number">1</span>; j &gt;= s[i - <span class="number">1</span>] + <span class="number">1</span>; j--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= cmd2; k++) &#123;</span><br><span class="line"><span class="keyword">if</span> (cmd1 == <span class="number">3</span>) &#123;</span><br><span class="line"><span class="comment">//printf("*");</span></span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">'*'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//printf("%c", j);</span></span><br><span class="line"><span class="built_in">putchar</span>(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">//都不满足输出原字符</span></span><br><span class="line"><span class="comment">//printf("%c", s[i]);</span></span><br><span class="line"><span class="built_in">putchar</span>(s[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">putchar</span>(s[len]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="作业调度方案"><a href="#作业调度方案" class="headerlink" title="作业调度方案"></a>作业调度方案</h1><h2 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.luogu.com.cn/problem/P1065" target="_blank" rel="noopener">luoguP1065</a></p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>按照题目所说的暴力即可，<code>ntime[i]</code>表示第 $ i $ 件物品当前最晚的完成时间，每一都从最晚的时间往后推，用一个<code>flag[i][j]</code>数组标记第 $ i $ 台机器在第 $ j $ 时是否被占用，只要没被占用就安排上</p><p>因为物品必须连续加工，中间断了一次便需要从头开始</p><p>最后对 $ ntime $ 遍历找到最大值便是答案</p><h2 id="AC代码-洛谷99分"><a href="#AC代码-洛谷99分" class="headerlink" title="AC代码(洛谷99分)"></a>AC代码(洛谷99分)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m ,n, ans = <span class="number">0</span>, s= <span class="number">0</span>, machine[<span class="number">25</span>], works[<span class="number">505</span>], time[<span class="number">25</span>][<span class="number">25</span>], ntime[<span class="number">25</span>], need[<span class="number">25</span>][<span class="number">25</span>];</span><br><span class="line"><span class="keyword">bool</span> flag[<span class="number">25</span>][<span class="number">505</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m * n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;works[i]);<span class="comment">//输入安排顺序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;need[i][j]);<span class="comment">//第i个工件在第j道工序需要什么机器 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;~</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;time[i][j]);<span class="comment">//第i个工件在第j道工序时的加工时间 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m * n; i++) &#123;</span><br><span class="line">machine[works[i]]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = ntime[works[i]] + <span class="number">1</span>;;j++) &#123;<span class="comment">//从空闲时开始遍历 </span></span><br><span class="line"><span class="keyword">if</span> (!flag[need[works[i]][machine[works[i]]]][j])<span class="comment">//未占用</span></span><br><span class="line">s++;<span class="comment">//时间++ </span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">s = <span class="number">0</span>;<span class="comment">//因为要连续，所以只要有一点不能使用就重来 </span></span><br><span class="line"><span class="keyword">if</span> (s == time[works[i]][machine[works[i]]]) &#123;<span class="comment">//时间足够 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j - s + <span class="number">1</span>; k &lt;= j; k++)&#123;</span><br><span class="line">                    flag[need[works[i]][machine[works[i]]]][k] = <span class="number">1</span>;<span class="comment">//标记为已用 </span></span><br><span class="line">&#125;</span><br><span class="line">                ntime[works[i]]=j;<span class="comment">//完成时间 </span></span><br><span class="line">                s = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">ans = <span class="built_in">std</span>::max(ans, ntime[i]);<span class="comment">//遍历完成时间取最大值 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="火柴棒等式"><a href="#火柴棒等式" class="headerlink" title="火柴棒等式"></a>火柴棒等式</h1><h2 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.luogu.com.cn/problem/P1149" target="_blank" rel="noopener">luoguP1149</a></p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>简单的暴力，枚举加数 $ a $ 和 $ b $ ， $ c $ 等于 $ a+b $ ，再拆分每一个数，算出火所需火柴棍的总数，等于 $ n-4 $ 就ans++</p><h2 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NUM[<span class="number">15</span>] = &#123;<span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">6</span>&#125;;<span class="comment">//每一个数字所需的火柴数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chai</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> NUM[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">while</span> (x) &#123;<span class="comment">//求出每一位的火柴棍数量</span></span><br><span class="line">ret += NUM[x % <span class="number">10</span>];</span><br><span class="line">x /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//freopen("matches.in", "r", stdin);</span></span><br><span class="line"><span class="comment">//freopen("matches.out", "w", stdout);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="comment">//if (n &lt; 13) &#123;</span></span><br><span class="line"><span class="comment">//printf("0");</span></span><br><span class="line"><span class="comment">//&#125; else if (n == 13) &#123;</span></span><br><span class="line"><span class="comment">//printf("1");</span></span><br><span class="line"><span class="comment">//&#125; else if (n == 14) &#123;</span></span><br><span class="line"><span class="comment">//printf("2");</span></span><br><span class="line"><span class="comment">//&#125; else if (n == 15) &#123;</span></span><br><span class="line"><span class="comment">//printf("8");</span></span><br><span class="line"><span class="comment">//&#125; else if (n == 16) &#123;</span></span><br><span class="line"><span class="comment">//printf("9");</span></span><br><span class="line"><span class="comment">//&#125; else if (n == 17) &#123;</span></span><br><span class="line"><span class="comment">//printf("6");</span></span><br><span class="line"><span class="comment">//&#125; else if (n == 18) &#123;</span></span><br><span class="line"><span class="comment">//printf("9");</span></span><br><span class="line"><span class="comment">//&#125; else if (n == 19) &#123;</span></span><br><span class="line"><span class="comment">//printf("29");</span></span><br><span class="line"><span class="comment">//&#125; else if (n == 20) &#123;</span></span><br><span class="line"><span class="comment">//printf("39");</span></span><br><span class="line"><span class="comment">//&#125; else if (n == 21) &#123;</span></span><br><span class="line"><span class="comment">//printf("38");</span></span><br><span class="line"><span class="comment">//&#125; else if (n == 22) &#123;</span></span><br><span class="line"><span class="comment">//printf("65");</span></span><br><span class="line"><span class="comment">//&#125; else if (n == 23) &#123;</span></span><br><span class="line"><span class="comment">//printf("88");</span></span><br><span class="line"><span class="comment">//&#125; else if (n == 24) &#123;</span></span><br><span class="line"><span class="comment">//printf("128");</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">n -= <span class="number">4</span>;<span class="comment">//减去加号和等号的火柴</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">999</span>; i++) &#123;<span class="comment">//可以判断，i和j必定小于999</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">999</span>; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> k = i + j;</span><br><span class="line"><span class="keyword">if</span> (chai(i) + chai(j) + chai(k) == n) &#123;</span><br><span class="line"><span class="comment">//printf("%d(%d)+%d(%d)=%d(%d)\n", i, chai(i), j, chai(j), k, chai(k));</span></span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数三角"><a href="#数三角" class="headerlink" title="数三角"></a>数三角</h1><h2 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="http://222.180.160.110:1024/problem/3202" target="_blank" rel="noopener">八中OJ-3202</a></p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>由 C2021ljs 提供。</p><p>首先在输入进来时，我们将所有的坐标过大两倍，也就是将每个网格又分成四个小格。这样的好处是什么呢？这样的话，在整个过程中就不会图(c)中被划分出的小三角形。</p><p>然后对于输入进来的木棍，我们需要标记它们连通（即之间有木棍），并且它们与木棍的中点也是连通的（网格过大后产生的），所以在输入时，我们可以将这些一起处理了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> lx[<span class="number">25</span>][<span class="number">25</span>][<span class="number">25</span>][<span class="number">25</span>];<span class="comment">//lx[i][j][x][y]表示(i,j)(x,y)之间有连线，连通</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> a, b, x, y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;a, &amp;b, &amp;x, &amp;y);</span><br><span class="line">a &lt;&lt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>; x &lt;&lt;= <span class="number">1</span>; y &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">lx[a][b][(a + x) &gt;&gt; <span class="number">1</span>][(b + y) &gt;&gt; <span class="number">1</span>] = <span class="number">1</span>; </span><br><span class="line">lx[(a + x) &gt;&gt; <span class="number">1</span>][(b + y) &gt;&gt; <span class="number">1</span>][a][b] = <span class="number">1</span>; </span><br><span class="line">lx[x][y][(a + x) &gt;&gt; <span class="number">1</span>][(b + y) &gt;&gt; <span class="number">1</span>] = <span class="number">1</span>; </span><br><span class="line">lx[(a + x) &gt;&gt; <span class="number">1</span>][(b + y) &gt;&gt; <span class="number">1</span>][x][y] = <span class="number">1</span>; </span><br><span class="line"><span class="comment">//(a,b),(x,y)连线的中点坐标为((a+x)/2,(b+y)/2)</span></span><br><span class="line">lx[a][b][x][y] = <span class="number">1</span>;</span><br><span class="line">lx[x][y][a][b] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们可以想， $ a $ 点与 $ b $ 点连通， $ a $ 点又与 $ c $ 点连通，那么只要 $ a,b,c $ 共线的话， $ b,c $ 不也连通（之间用木棍连接）吗？</p><p>所以我们可以枚举 $ b,c $ ,在枚举中转点  $ a $ ，再进行判断即可。</p><p>如何判断 $ a,b,c $ 共线呢？因为 $ a $ 点与 $ b $ 点连通， $ a $ 点又与 $ c $ 点连通(这也是Floyd最短路的核心思想)，所以只用判断 $ ab $ 与 $ ac $ ，斜率相同就行了(关于斜率，请自行学习一次函数)</p><p>斜率公式 $ k=\frac{y2-y1}{x2-x1}$</p><p>将坐标带入，即：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">18</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">18</span>; j++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= <span class="number">18</span>; x++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt;= <span class="number">18</span>; y++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= <span class="number">18</span>; l++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt;= <span class="number">18</span>; r++)</span><br><span class="line"><span class="keyword">if</span> (lx[i][j][x][y] &amp;&amp; lx[i][j][l][r] &amp;&amp; check(i, j, x, y) </span><br><span class="line">&amp;&amp; check(i, j, l, r) &amp;&amp; ((r - j) * (x - i) == (y - j) * (l - i))) &#123;</span><br><span class="line">lx[x][y][l][r] = <span class="number">1</span>;</span><br><span class="line">lx[l][r][x][y] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩大后的网格任意两点连线求完了，我们就可以枚举任意三个互不相同的点，只要三点中任意两点之间有连线且三点不共线，就能构成三角形。</p><h2 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">35</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> flag[MAXN][MAXN][MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;a[<span class="number">1</span>], &amp;a[<span class="number">2</span>], &amp;a[<span class="number">3</span>], &amp;a[<span class="number">4</span>]);</span><br><span class="line">a[<span class="number">1</span>] *= <span class="number">2</span>, a[<span class="number">2</span>] *= <span class="number">2</span>, a[<span class="number">3</span>] *= <span class="number">2</span>, a[<span class="number">4</span>] *= <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">3</span>] + a[<span class="number">4</span>] - a[<span class="number">1</span>] - a[<span class="number">2</span>] == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">2</span>] == a[<span class="number">4</span>]) &#123;</span><br><span class="line">flag[a[<span class="number">1</span>] + <span class="number">1</span>][a[<span class="number">2</span>]][a[<span class="number">3</span>]][a[<span class="number">2</span>]] = <span class="number">1</span>;</span><br><span class="line">flag[a[<span class="number">3</span>]][a[<span class="number">2</span>]][a[<span class="number">1</span>] + <span class="number">1</span>][a[<span class="number">2</span>]] = <span class="number">1</span>;</span><br><span class="line">flag[a[<span class="number">1</span>] + <span class="number">1</span>][a[<span class="number">2</span>]][a[<span class="number">1</span>]][a[<span class="number">2</span>]] = <span class="number">1</span>;</span><br><span class="line">flag[a[<span class="number">1</span>]][a[<span class="number">2</span>]][a[<span class="number">1</span>] + <span class="number">1</span>][a[<span class="number">2</span>]] = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">1</span>] == a[<span class="number">3</span>]) &#123;</span><br><span class="line">flag[a[<span class="number">1</span>]][a[<span class="number">2</span>] + <span class="number">1</span>][a[<span class="number">1</span>]][a[<span class="number">4</span>]] = <span class="number">1</span>;</span><br><span class="line">flag[a[<span class="number">1</span>]][a[<span class="number">4</span>]][a[<span class="number">1</span>]][a[<span class="number">2</span>] + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">flag[a[<span class="number">1</span>]][a[<span class="number">2</span>] + <span class="number">1</span>][a[<span class="number">1</span>]][a[<span class="number">2</span>]] = <span class="number">1</span>;</span><br><span class="line">flag[a[<span class="number">1</span>]][a[<span class="number">2</span>]][a[<span class="number">1</span>]][a[<span class="number">2</span>] + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">1</span>] + a[<span class="number">2</span>] - a[<span class="number">3</span>] - a[<span class="number">4</span>] == <span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">2</span>] == a[<span class="number">4</span>]) &#123;</span><br><span class="line">flag[a[<span class="number">1</span>]][a[<span class="number">2</span>]][a[<span class="number">3</span>] + <span class="number">1</span>][a[<span class="number">2</span>]] = <span class="number">1</span>;</span><br><span class="line">flag[a[<span class="number">3</span>] + <span class="number">1</span>][a[<span class="number">2</span>]][a[<span class="number">1</span>]][a[<span class="number">2</span>]] = <span class="number">1</span>;</span><br><span class="line">flag[a[<span class="number">3</span>]][a[<span class="number">2</span>]][a[<span class="number">3</span>] + <span class="number">1</span>][a[<span class="number">2</span>]] = <span class="number">1</span>;</span><br><span class="line">flag[a[<span class="number">3</span>]][a[<span class="number">2</span>]][a[<span class="number">3</span>] + <span class="number">1</span>][a[<span class="number">2</span>]] = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">1</span>] == a[<span class="number">3</span>]) &#123;</span><br><span class="line">flag[a[<span class="number">1</span>]][a[<span class="number">2</span>]][a[<span class="number">1</span>]][a[<span class="number">4</span>] + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">flag[a[<span class="number">1</span>]][a[<span class="number">4</span>] + <span class="number">1</span>][a[<span class="number">1</span>]][a[<span class="number">2</span>]] = <span class="number">1</span>;</span><br><span class="line">flag[a[<span class="number">1</span>]][a[<span class="number">4</span>] + <span class="number">1</span>][a[<span class="number">1</span>]][a[<span class="number">4</span>]] = <span class="number">1</span>;</span><br><span class="line">flag[a[<span class="number">1</span>]][a[<span class="number">4</span>]][a[<span class="number">1</span>]][a[<span class="number">4</span>] + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">1</span>] + a[<span class="number">2</span>] - a[<span class="number">3</span>] - a[<span class="number">4</span>] == <span class="number">4</span>) &#123;</span><br><span class="line">flag[a[<span class="number">3</span>] + <span class="number">1</span>][a[<span class="number">4</span>] + <span class="number">1</span>][a[<span class="number">1</span>]][a[<span class="number">2</span>]] = <span class="number">1</span>;</span><br><span class="line">flag[a[<span class="number">1</span>]][a[<span class="number">2</span>]][a[<span class="number">3</span>] + <span class="number">1</span>][a[<span class="number">4</span>] + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">flag[a[<span class="number">3</span>]][a[<span class="number">4</span>]][a[<span class="number">3</span>] + <span class="number">1</span>][a[<span class="number">4</span>] + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">flag[a[<span class="number">3</span>] + <span class="number">1</span>][a[<span class="number">4</span>] + <span class="number">1</span>][a[<span class="number">3</span>]][a[<span class="number">4</span>]] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">3</span>] + a[<span class="number">4</span>] - a[<span class="number">1</span>] - a[<span class="number">2</span>] == <span class="number">4</span>) &#123;</span><br><span class="line">flag[a[<span class="number">1</span>] + <span class="number">1</span>][a[<span class="number">2</span>] + <span class="number">1</span>][a[<span class="number">3</span>]][a[<span class="number">4</span>]] = <span class="number">1</span>;</span><br><span class="line">flag[a[<span class="number">3</span>]][a[<span class="number">4</span>]][a[<span class="number">1</span>] + <span class="number">1</span>][a[<span class="number">2</span>] + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">flag[a[<span class="number">1</span>]][a[<span class="number">2</span>]][a[<span class="number">1</span>] + <span class="number">1</span>][a[<span class="number">2</span>] + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">flag[a[<span class="number">1</span>] + <span class="number">1</span>][a[<span class="number">2</span>] + <span class="number">1</span>][a[<span class="number">1</span>]][a[<span class="number">2</span>]] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">1</span>] + a[<span class="number">2</span>] == a[<span class="number">3</span>] + a[<span class="number">4</span>]) &#123;</span><br><span class="line">flag[a[<span class="number">1</span>]][a[<span class="number">2</span>]][(a[<span class="number">1</span>] + a[<span class="number">3</span>]) / <span class="number">2</span>][(a[<span class="number">2</span>] + a[<span class="number">4</span>]) / <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">flag[(a[<span class="number">1</span>] + a[<span class="number">3</span>]) / <span class="number">2</span>][(a[<span class="number">2</span>] + a[<span class="number">4</span>]) / <span class="number">2</span>][a[<span class="number">1</span>]][a[<span class="number">2</span>]] = <span class="number">1</span>;</span><br><span class="line">flag[a[<span class="number">3</span>]][a[<span class="number">4</span>]][(a[<span class="number">1</span>] + a[<span class="number">3</span>]) / <span class="number">2</span>][(a[<span class="number">2</span>] + a[<span class="number">4</span>]) / <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">flag[(a[<span class="number">1</span>] + a[<span class="number">3</span>]) / <span class="number">2</span>][(a[<span class="number">2</span>] + a[<span class="number">4</span>]) / <span class="number">2</span>][a[<span class="number">3</span>]][a[<span class="number">4</span>]] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">flag[a[<span class="number">1</span>]][a[<span class="number">2</span>]][a[<span class="number">3</span>]][a[<span class="number">4</span>]] = <span class="number">1</span>;</span><br><span class="line">flag[a[<span class="number">3</span>]][a[<span class="number">4</span>]][a[<span class="number">1</span>]][a[<span class="number">2</span>]] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">18</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">18</span>; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">18</span>; k++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt;= <span class="number">18</span>; i1++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j1 = <span class="number">0</span>; j1 &lt;= <span class="number">18</span>; j1++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k1 = <span class="number">0</span>; k1 &lt;= <span class="number">18</span>; k1++) &#123;</span><br><span class="line"><span class="keyword">if</span> (flag[i][i1][j][j1] == <span class="number">1</span> &amp;&amp; flag[i][i1][k][k1] == <span class="number">1</span> &amp;&amp; !(i == j &amp;&amp; i1 == j1) &amp;&amp; !(i == k &amp;&amp; i1 == k1)) &#123;</span><br><span class="line"><span class="keyword">if</span> ((k1 - i1) * (j - i) - (j1 - i1) * (k - i) == <span class="number">0</span>) &#123;</span><br><span class="line">flag[j][j1][k][k1] = <span class="number">1</span>;</span><br><span class="line">flag[k][k1][j][j1] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">18</span>; i++) &#123;  <span class="comment">//输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">18</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">18</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt;= <span class="number">18</span>; i1++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j1 = <span class="number">0</span>; j1 &lt;= <span class="number">18</span>; j1++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> k1 = <span class="number">0</span>; k1 &lt;= <span class="number">18</span>; k1++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (flag[i][i1][j][j1] == <span class="number">1</span> &amp;&amp; flag[i][i1][k][k1] == <span class="number">1</span> &amp;&amp; flag[j][j1][k][k1] == <span class="number">1</span> &amp;&amp;</span><br><span class="line">                                !(i == j &amp;&amp; i1 == j1) &amp;&amp; !(i == k &amp;&amp; i1 == k1) &amp;&amp; !(j == k &amp;&amp; j1 == k1)) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((k1 - i1) * (j - i) - (j1 - i1) * (k - i)) &#123;</span><br><span class="line">                                ans++;</span><br><span class="line">&#125;  </span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans / <span class="number">6</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;字符串的展开&quot;&gt;&lt;a href=&quot;#字符串的展开&quot; class=&quot;headerlink&quot; title=&quot;字符串的展开&quot;&gt;&lt;/a&gt;字符串的展开&lt;/h1&gt;&lt;h2 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P1098&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;luoguP1098&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h2&gt;&lt;p&gt;简单模拟，按照题目要求来一步步实现即可&lt;/p&gt;
    
    </summary>
    
    
      <category term="测试" scheme="https://liu-zhou-l.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="模拟" scheme="https://liu-zhou-l.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>二叉堆</title>
    <link href="https://liu-zhou-l.github.io/posts/69c852d4/"/>
    <id>https://liu-zhou-l.github.io/posts/69c852d4/</id>
    <published>2020-07-22T07:14:00.000Z</published>
    <updated>2023-09-21T08:20:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><blockquote><p>二叉堆是一种特殊的堆，二叉堆是完全二元树（二叉树）或者是近似完全二元树（二叉树）。二叉堆有两种：最大堆和最小堆。最大堆：父结点的键值总是大于或等于任何一个子节点的键值；最小堆：父结点的键值总是小于或等于任何一个子节点的键值。</p></blockquote><h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><blockquote><p>二叉堆是一种数组对象，它可以被视为一棵完全二叉树。树中每个结点与数组中存放该结点中值的那个元素相对应</p></blockquote><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMS5heDF4LmNvbS8yMDIwLzA3LzIwL1U0N0F4SS5wbmc?x-oss-process=image/format,png" alt="二叉堆存储示意图"></p><h2 id="put"><a href="#put" class="headerlink" title="put"></a>put</h2><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><blockquote><p>1.在堆尾加入一个元素，并把这个结点置为当前结点</p><p>2、比较当前结点和它父结点的大小<br>如果当前结点小于父结点，则交换它们的值，并把父结点置为当前结点，继续转2<br>如果当前结点大于等于父结点，则转3</p><p>3、结束</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Put</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">heap[++size] = num;</span><br><span class="line"><span class="keyword">int</span> x = size;</span><br><span class="line"><span class="keyword">while</span> (x &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (heap[x] &lt; heap[x &gt;&gt; <span class="number">1</span>]) &#123;</span><br><span class="line">swap(heap[x], heap[x &gt;&gt; <span class="number">1</span>]);</span><br><span class="line">x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><h3 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h3><blockquote><p>1、取出堆中根结点的值</p><p>2、把堆的最后一个结点(heap_size)放到根的位置上，把根覆盖掉，     堆长度减一</p><p>3、把根结点置为当前父结点，即当前操作结点now</p><p>4、如果now无儿子(now&gt;heap_size/2)，则转6；否则，把now的两(或一)个儿子中值较小的那一个置为当前子结点son</p><p>5、比较now与son的值，如果now的值小于等于son，转6；否则交换     两个结点的值，把now指向son，转4</p><p>6、结束</p></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">heap[<span class="number">1</span>] = heap[size--];</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (x &lt;= (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">int</span> son = x * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (son &lt; size &amp;&amp; heap[son + <span class="number">1</span>] &lt; heap[son]) son++;</span><br><span class="line"><span class="keyword">if</span> (heap[x] &lt;= heap[son]) <span class="keyword">break</span>;</span><br><span class="line">swap(heap[x], heap[son]);</span><br><span class="line">x = son;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><hr><p>n个数，我们利用堆把它们从小到大排序。</p><hr><p><strong>样例输入</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">2 3 9 4 5 3 6 7</span><br></pre></td></tr></table></figure><br><strong>样例输入</strong></p><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">2 3 9 4 5 3 6 7</span><br></pre></td></tr></table></figure></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>利用小根堆的特性，最小值在根元素，每次取出根元素并删除，直到堆为空即可</p><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, heap[MAXN], size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Put</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = size;</span><br><span class="line"><span class="keyword">while</span> (x &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (heap[x] &lt; heap[x &gt;&gt; <span class="number">1</span>]) &#123;</span><br><span class="line">swap(heap[x], heap[x &gt;&gt; <span class="number">1</span>]);</span><br><span class="line">x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">heap[<span class="number">1</span>] = heap[size--];</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (x &lt;= (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">int</span> son = x * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (son &lt; size &amp;&amp; heap[son + <span class="number">1</span>] &lt; heap[son]) son++;</span><br><span class="line"><span class="keyword">if</span> (heap[x] &lt;= heap[son]) <span class="keyword">break</span>;</span><br><span class="line">swap(heap[x], heap[son]);</span><br><span class="line">x = son;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;heap[++size]); </span><br><span class="line">Put();   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, heap[<span class="number">1</span>]);</span><br><span class="line">Pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并果子"><a href="#合并果子" class="headerlink" title="合并果子"></a>合并果子</h2><hr><p><a href="https://www.luogu.com.cn/problem/P1090" target="_blank" rel="noopener">luoguP1090</a></p><hr><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>用贪心来思考，每次肯定是取出最小的两堆进行合并，这里也利用了小根堆的特性，每次取出两个根元素，将它们的和累加在ans上，并作为一个新元素加入堆，<br>重复执行此操作n-1次，直到堆中只剩一个元素为止</p><h3 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, heap[MAXN], size = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Put</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = size;</span><br><span class="line"><span class="keyword">while</span> (x &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (heap[x] &lt; heap[x &gt;&gt; <span class="number">1</span>]) &#123;</span><br><span class="line">swap(heap[x], heap[x &gt;&gt; <span class="number">1</span>]);</span><br><span class="line">x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">heap[<span class="number">1</span>] = heap[size--];</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (x &lt;= (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">int</span> son = x * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (son &lt; size &amp;&amp; heap[son + <span class="number">1</span>] &lt; heap[son]) son++;</span><br><span class="line"><span class="keyword">if</span> (heap[x] &lt;= heap[son]) <span class="keyword">break</span>;</span><br><span class="line">swap(heap[x], heap[son]);</span><br><span class="line">x = son;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;heap[++size]); </span><br><span class="line">Put();   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> a = heap[<span class="number">1</span>];</span><br><span class="line">Pop();</span><br><span class="line"><span class="keyword">int</span> b = heap[<span class="number">1</span>];</span><br><span class="line">Pop();</span><br><span class="line">ans += a + b;</span><br><span class="line">heap[++size] = a + b;</span><br><span class="line">Put();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;二叉堆是一种特殊的堆，二叉堆是完全二元树（二叉树）或者是近似完全二元树（二叉树）。二叉堆有两种：最大堆和最小堆。最大堆：父结点的键值总是大于或等于任何一个子节点的键值；最小堆：父结点的键值总是小于或等于任何一个子节点的键值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;存储&quot;&gt;&lt;a href=&quot;#存储&quot; class=&quot;headerlink&quot; title=&quot;存储&quot;&gt;&lt;/a&gt;存储&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;二叉堆是一种数组对象，它可以被视为一棵完全二叉树。树中每个结点与数组中存放该结点中值的那个元素相对应&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMS5heDF4LmNvbS8yMDIwLzA3LzIwL1U0N0F4SS5wbmc?x-oss-process=image/format,png&quot; alt=&quot;二叉堆存储示意图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://liu-zhou-l.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="堆" scheme="https://liu-zhou-l.github.io/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>区间DP</title>
    <link href="https://liu-zhou-l.github.io/posts/628fb573/"/>
    <id>https://liu-zhou-l.github.io/posts/628fb573/</id>
    <published>2020-07-22T07:09:00.000Z</published>
    <updated>2023-09-21T08:20:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><blockquote><p>区间类动态规划是线性动态规划的扩展，它在分阶段地划分问题时，与阶段中元素出现的顺序和由前一阶段的哪些元素合并而来由很大的关系。令状态 $ f(i,j) $ 表示将下标位置  到  的所有元素合并能获得的价值的最大值，那么 $ f(i,j)=max{f(i,k)+f(k+1,j)+cost} $ ，$ cost $  为将这两组元素合并起来的代价。</p></blockquote><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p><strong>合并</strong> ：即将两个或多个部分进行整合，当然也可以反过来；<br><strong>特征</strong> ：能将问题分解为能两两合并的形式；<br><strong>求解</strong> ：对整个问题设最优值，枚举合并点，将问题分解为左右两个部分，最后合并两个部分的最优值得到原问题的最优值。</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><h2 id="石子合并1"><a href="#石子合并1" class="headerlink" title="石子合并1"></a>石子合并1</h2><p><a href="http://222.180.160.110:1024/problem/3265" target="_blank" rel="noopener">石子合并1</a></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>区间DP板题，使用前缀和进行优化，可通过下图进行理解</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMS5heDF4LmNvbS8yMDIwLzA3LzE4L1UyTVE5cy5wbmc?x-oss-process=image/format,png" alt=""></p><p>在此图中，g，h，i，j为题目所给的每堆的重量，k，l，m为长度为二时的最优策略…<br>如果要求区间k的值，则可以通过区间g和h求出，而点D则为分割点，其它线段以此类推，需要枚举的是分割点，以此最终求出答案</p><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">105</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m[MAXN][MAXN], a[MAXN], s[MAXN] = &#123;&#125;;<span class="comment">//m[i][j]表示合并第i到第j个元素的最小费用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qujianhe</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123; <span class="keyword">return</span> s[end] - s[start - <span class="number">1</span>]; &#125;<span class="comment">//求区间和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">s[i] = s[i - <span class="number">1</span>] + a[i];<span class="comment">//前缀和</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len++) &#123;<span class="comment">//枚举合并的堆数量</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - len + <span class="number">1</span>; i++) &#123;<span class="comment">//枚举合并的第一个元素</span></span><br><span class="line">m[i][i + len - <span class="number">1</span>] = <span class="number">0x3f3f3f</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; i + len - <span class="number">1</span>; j++) &#123;<span class="comment">//枚举分割的点</span></span><br><span class="line">m[i][i + len - <span class="number">1</span>] = <span class="built_in">std</span>::min(m[i][i + len - <span class="number">1</span>], m[i][j] + m[j + <span class="number">1</span>][i + len - <span class="number">1</span>] + qujianhe(i, i + len - <span class="number">1</span>));</span><br><span class="line"><span class="comment">//状态转移方程 m[i][j] = min(m[i][j], m[i][j] + m[k + 1][j] + qujianhe(i, j))</span></span><br><span class="line"><span class="comment">//m[i][j] + m[k + 1][j]为合并两小堆的分别的代价的和，qujianhe(i, j)为将两小堆合并的代价和</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, m[<span class="number">1</span>][n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长回文串"><a href="#最长回文串" class="headerlink" title="最长回文串"></a>最长回文串</h2><p><a href="http://222.180.160.110:1024/problem/7092" target="_blank" rel="noopener">最长回文串</a></p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p><img src="https://img-blog.csdnimg.cn/2020072021015988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdV96aG91X3pob3U=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMS5heDF4LmNvbS8yMDIwLzA3LzIwL1U0NU1nUC5wbmc?x-oss-process=image/format,png" alt=""></p><h3 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> strl, f[MAXN][MAXN];</span><br><span class="line"><span class="keyword">char</span> str[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);</span><br><span class="line">strl = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strl; i++) &#123;</span><br><span class="line">f[i][i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= strl; len++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= strl - len; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] == str[i + len - <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">if</span> (f[i + <span class="number">1</span>][i + len - <span class="number">2</span>] == len - <span class="number">2</span>) &#123;</span><br><span class="line">f[i][i + len - <span class="number">1</span>] = len;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">f[i][i + len - <span class="number">1</span>] = <span class="built_in">std</span>::max(f[i + <span class="number">1</span>][i + len - <span class="number">1</span>], f[i][i + len - <span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">f[i][i + len - <span class="number">1</span>] = <span class="built_in">std</span>::max(f[i + <span class="number">1</span>][i + len - <span class="number">1</span>], f[i][i + len - <span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, f[<span class="number">0</span>][strl - <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;区间类动态规划是线性动态规划的扩展，它在分阶段地划分问题时，与阶段中元素出现的顺序和由前一阶段的哪些元素合并而来由很大的关系。令状态 $ f(i,j) $ 表示将下标位置  到  的所有元素合并能获得的价值的最大值，那么 $ f(i,j)=max{f(i,k)+f(k+1,j)+cost} $ ，$ cost $  为将这两组元素合并起来的代价。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;特点&quot;&gt;&lt;a href=&quot;#特点&quot; class=&quot;headerlink&quot; title=&quot;特点&quot;&gt;&lt;/a&gt;特点&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;合并&lt;/strong&gt; ：即将两个或多个部分进行整合，当然也可以反过来；&lt;br&gt;&lt;strong&gt;特征&lt;/strong&gt; ：能将问题分解为能两两合并的形式；&lt;br&gt;&lt;strong&gt;求解&lt;/strong&gt; ：对整个问题设最优值，枚举合并点，将问题分解为左右两个部分，最后合并两个部分的最优值得到原问题的最优值。&lt;/p&gt;
&lt;h1 id=&quot;练习题&quot;&gt;&lt;a href=&quot;#练习题&quot; class=&quot;headerlink&quot; title=&quot;练习题&quot;&gt;&lt;/a&gt;练习题&lt;/h1&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://liu-zhou-l.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="dp" scheme="https://liu-zhou-l.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>暑假集训前难题复习</title>
    <link href="https://liu-zhou-l.github.io/posts/2d0d7c25/"/>
    <id>https://liu-zhou-l.github.io/posts/2d0d7c25/</id>
    <published>2020-07-14T14:50:00.000Z</published>
    <updated>2023-09-21T08:20:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="扩散"><a href="#扩散" class="headerlink" title="扩散"></a>扩散</h1><p><a href="https://www.luogu.com.cn/problem/P1661" target="_blank" rel="noopener">洛谷P1661</a></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>二分(寻找最小的时间)+并查集(检验是否构成连通块)</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">55</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">LL x;</span><br><span class="line">LL y;</span><br><span class="line">&#125; nodes[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, dict[MAXN];</span><br><span class="line">LL left = <span class="number">0</span>, right = <span class="number">1e9</span>;<span class="comment">//二分的极值</span></span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">distance</span> <span class="params">(node a, node b)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">abs</span>(a.x - b.x) + <span class="built_in">abs</span>(a.y - b.y); &#125;<span class="comment">//返回两个点的曼哈顿距离</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zuisu</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dict[x] == x) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> zuisu(dict[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span> <span class="params">(LL x)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dict, <span class="number">0</span>, <span class="keyword">sizeof</span>(dict));<span class="comment">//每次检查都将上一次的标记重置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">dict[i] = i;<span class="comment">//并查集初始化</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (distance(nodes[i], nodes[j]) &lt;= x * <span class="number">2</span>) &#123;</span><br><span class="line"><span class="comment">//因为扩散是四个方向都有,所以要求两个点的曼哈顿距离的二分之一小于x,为了保持精度,这里为小于二倍x</span></span><br><span class="line">LL xx = zuisu(i);</span><br><span class="line">LL yy = zuisu(j);</span><br><span class="line">dict[xx] = yy;<span class="comment">//并查集找祖宗</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (dict[i] == i) sum++;<span class="comment">//统计祖宗数,即查看共有多少个连通块</span></span><br><span class="line"><span class="keyword">return</span> (sum == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;nodes[i].x, &amp;nodes[i].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">while</span> (right &gt;= left) &#123;<span class="comment">//二分</span></span><br><span class="line">LL mid = (right + left) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (check(mid)) &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">ans = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;扩散&quot;&gt;&lt;a href=&quot;#扩散&quot; class=&quot;headerlink&quot; title=&quot;扩散&quot;&gt;&lt;/a&gt;扩散&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P1661&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;洛谷P1661&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h2&gt;&lt;p&gt;二分(寻找最小的时间)+并查集(检验是否构成连通块)&lt;/p&gt;
&lt;h2 id=&quot;AC代码&quot;&gt;&lt;a href=&quot;#AC代码&quot; class=&quot;headerlink&quot; title=&quot;AC代码&quot;&gt;&lt;/a&gt;AC代码&lt;/h2&gt;
    
    </summary>
    
    
      <category term="日常题目" scheme="https://liu-zhou-l.github.io/categories/%E6%97%A5%E5%B8%B8%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="并查集" scheme="https://liu-zhou-l.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="二分" scheme="https://liu-zhou-l.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>STL-map</title>
    <link href="https://liu-zhou-l.github.io/posts/bbf9d7b7/"/>
    <id>https://liu-zhou-l.github.io/posts/bbf9d7b7/</id>
    <published>2020-06-20T06:34:00.000Z</published>
    <updated>2023-09-21T08:20:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p><code>Map</code>是<code>STL</code>的一个关联容器，它提供一对一（其中第一个可以称为关键字，每个关键字只能在<code>map</code>中出现一次，第二个可能称为该关键字的值）的数据处理能力，由于这个特性，它完成有可能在我们处理一对一数据的时候，在编程上提供快速通道。</p><h2 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h2><p><code>map</code>可以看做一个特殊的数组，其下标可以为任意类型，即<code>key</code></p><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;Type, Type&gt; dictionary</span><br></pre></td></tr></table></figure><h2 id="常用成员函数"><a href="#常用成员函数" class="headerlink" title="常用成员函数"></a>常用成员函数</h2><h3 id="erase"><a href="#erase" class="headerlink" title="erase"></a>erase</h3><p>删除指定<code>map</code>中指定的元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dictionary.erase(<span class="string">"an"</span>) <span class="comment">//删除键为“an”的元素</span></span><br><span class="line">dictionary.erase(map_it) <span class="comment">//删除迭代器指向的的元素</span></span><br></pre></td></tr></table></figure><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>在<code>map</code>中添加元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">maplive.insert(pair&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt;(<span class="number">321</span>,<span class="string">"hai"</span>));<span class="comment">//插入一个元素，key为321，value为hai</span></span><br><span class="line">maplive.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt;::value_type(<span class="number">321</span>,<span class="string">"hai"</span>));<span class="comment">//同上</span></span><br><span class="line"><span class="comment">//另:</span></span><br><span class="line">maplive[<span class="number">112</span>]=<span class="string">"April"</span>;<span class="comment">//map中最简单最常用的插入添加</span></span><br></pre></td></tr></table></figure><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>在<code>map</code>中查找关键<code>key</code>，当所查找的关键<code>key</code>出现时，它返回数据所在对象的位置，如果沒有，返回值与<code>end</code>函数的值相同<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在map中寻找key为"123"的元素，并返回其value</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator iter = dictionary.find(<span class="string">"123"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(iter != dictionary.end()) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Find, the value is %d\n"</span>, iter-&gt;second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Do not Find\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Map&lt;/code&gt;是&lt;code&gt;STL&lt;/code&gt;的一个关联容器，它提供一对一（其中第一个可以称为关键字，每个关键字只能在&lt;code&gt;map&lt;/code&gt;中出现一次，第二个可能称为该关键字的值）的数据处理能力，由于这个特性，它完成有可能在我们处理一对一数据的时候，在编程上提供快速通道。&lt;/p&gt;
&lt;h2 id=&quot;个人理解&quot;&gt;&lt;a href=&quot;#个人理解&quot; class=&quot;headerlink&quot; title=&quot;个人理解&quot;&gt;&lt;/a&gt;个人理解&lt;/h2&gt;&lt;p&gt;&lt;code&gt;map&lt;/code&gt;可以看做一个特殊的数组，其下标可以为任意类型，即&lt;code&gt;key&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;基本操作&quot;&gt;&lt;a href=&quot;#基本操作&quot; class=&quot;headerlink&quot; title=&quot;基本操作&quot;&gt;&lt;/a&gt;基本操作&lt;/h1&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://liu-zhou-l.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="map" scheme="https://liu-zhou-l.github.io/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2814 家谱</title>
    <link href="https://liu-zhou-l.github.io/posts/ff17b799/"/>
    <id>https://liu-zhou-l.github.io/posts/ff17b799/</id>
    <published>2020-06-20T06:31:00.000Z</published>
    <updated>2023-09-21T08:20:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目传送门"><a href="#题目传送门" class="headerlink" title="题目传送门"></a>题目传送门</h1><p><a href="https://www.luogu.com.cn/problem/P2814" target="_blank" rel="noopener">洛谷 P2814 家谱</a></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><del>水的</del>典型的并查集题目，但在建立关系时需要有一定的思考，因为名字都是字符串，所以这里采用了<code>map</code>以建立名字和名字之间的关系</p><h1 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; persons;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s, t, p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">zuisu</span><span class="params">(<span class="built_in">string</span> x)</span> </span>&#123;<span class="comment">//溯源函数</span></span><br><span class="line">    <span class="keyword">if</span> (persons[x] == x) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> persons[x] = zuisu(persons[x]);<span class="comment">//找到后更新关系，以后就不用一代一代的查找了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">string</span> x, <span class="built_in">string</span> y)</span> </span>&#123;<span class="comment">//将x和y建立关系</span></span><br><span class="line">    <span class="built_in">string</span> xx = zuisu(x);</span><br><span class="line">    <span class="keyword">if</span> (xx != y)</span><br><span class="line">        persons[y] = xx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s &amp;&amp; s != <span class="string">"$"</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'#'</span>) &#123;</span><br><span class="line">            t = s.substr(<span class="number">1</span>);<span class="comment">//从第二个元素开始将名字保存在变量t中</span></span><br><span class="line">            <span class="keyword">if</span> (persons[t] == <span class="string">""</span>) &#123;</span><br><span class="line">                persons[t] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'+'</span>) &#123;</span><br><span class="line">            p = s.substr(<span class="number">1</span>);</span><br><span class="line">            f(t, p);<span class="comment">//将t和p建立关系</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'?'</span>) &#123;</span><br><span class="line">            p = s.substr(<span class="number">1</span>);</span><br><span class="line">            zuisu(p);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="string">" "</span> &lt;&lt; persons[p] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目传送门&quot;&gt;&lt;a href=&quot;#题目传送门&quot; class=&quot;headerlink&quot; title=&quot;题目传送门&quot;&gt;&lt;/a&gt;题目传送门&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P2814&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;洛谷 P2814 家谱&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;p&gt;&lt;del&gt;水的&lt;/del&gt;典型的并查集题目，但在建立关系时需要有一定的思考，因为名字都是字符串，所以这里采用了&lt;code&gt;map&lt;/code&gt;以建立名字和名字之间的关系&lt;/p&gt;
&lt;h1 id=&quot;AC代码&quot;&gt;&lt;a href=&quot;#AC代码&quot; class=&quot;headerlink&quot; title=&quot;AC代码&quot;&gt;&lt;/a&gt;AC代码&lt;/h1&gt;
    
    </summary>
    
    
      <category term="日常题目" scheme="https://liu-zhou-l.github.io/categories/%E6%97%A5%E5%B8%B8%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="map" scheme="https://liu-zhou-l.github.io/tags/map/"/>
    
      <category term="并查集" scheme="https://liu-zhou-l.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>数列的整除性</title>
    <link href="https://liu-zhou-l.github.io/posts/d17c7465/"/>
    <id>https://liu-zhou-l.github.io/posts/d17c7465/</id>
    <published>2020-05-29T15:36:00.000Z</published>
    <updated>2023-09-21T08:20:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1356" target="_blank" rel="noopener">luoguP1356</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n, k, s[MAXN];</span><br><span class="line"><span class="keyword">bool</span>  f[MAXN][<span class="number">105</span>];<span class="comment">////f[i][j]表示前i个数字运算之后余数是否为j</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"><span class="keyword">while</span>(t --) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;s[i]);</span><br><span class="line">s[i] = <span class="keyword">int</span>(<span class="built_in">fabs</span>(s[i])) % k;<span class="comment">//s[i]为第i个元素模k的值 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));<span class="comment">//清除前一次的记录 </span></span><br><span class="line">f[<span class="number">1</span>][s[<span class="number">1</span>]] = <span class="number">1</span>;<span class="comment">//初始化 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = k - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j --) &#123;</span><br><span class="line"><span class="keyword">if</span>(f[i - <span class="number">1</span>][j]) &#123;<span class="comment">//如果前i - 1个元素模k等于j </span></span><br><span class="line">f[i][(j + s[i]) % k] = <span class="number">1</span>;<span class="comment">//那么前i-1个值的和加上第i个元素模k等于加上第i个元素后模k的值</span></span><br><span class="line">f[i][((j - s[i]) % k + k) % k] = <span class="number">1</span>;<span class="comment">//前i-1个值的和减去第i个元素模k的值为j减去第i个元素后模k再加k的值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(f[n][<span class="number">0</span>]) &#123;<span class="comment">//检查所有元素的和能否被k整除 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Divisible\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Not divisible\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P1356&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;luoguP1356&lt;/a&gt;&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;t
      
    
    </summary>
    
    
      <category term="日常题目" scheme="https://liu-zhou-l.github.io/categories/%E6%97%A5%E5%B8%B8%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="dp" scheme="https://liu-zhou-l.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>传纸条</title>
    <link href="https://liu-zhou-l.github.io/posts/680420e/"/>
    <id>https://liu-zhou-l.github.io/posts/680420e/</id>
    <published>2020-05-29T15:33:00.000Z</published>
    <updated>2023-09-21T08:20:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1006" target="_blank" rel="noopener">luogu-P1006</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">55</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, n, a[MAXN][MAXN], f[MAXN][MAXN][MAXN][MAXN];<span class="comment">//f[i][j][k][l] 为两纸条分别传到(i, j),(k, l)的最大好感度</span></span><br><span class="line"><span class="keyword">bool</span> flag[MAXN][MAXN] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MAX</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::max(<span class="built_in">std</span>::max(i, j), <span class="built_in">std</span>::max(k, l));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; k++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= n; l++) &#123;<span class="comment">//暴力枚举 </span></span><br><span class="line">f[i][j][k][l] = MAX(f[i - <span class="number">1</span>][j][k - <span class="number">1</span>][l],  f[i - <span class="number">1</span>][j][k][l - <span class="number">1</span>], f[i][j - <span class="number">1</span>][k - <span class="number">1</span>][l], f[i][j - <span class="number">1</span>][k][l - <span class="number">1</span>]) + a[i][j] + a[k][l];</span><br><span class="line"> <span class="comment">//一张纸条有两种传递的方式，两张一共有四种方式，取好感度最大的一个 </span></span><br><span class="line"><span class="keyword">if</span>(i == k &amp;&amp; j == l) &#123;<span class="comment">//如果走到一个位置 </span></span><br><span class="line">f[i][j][k][l] -= a[i][j];<span class="comment">//减去其中一个的好感度</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, f[m][n][m][n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P1006&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;luogu-P1006&lt;/a&gt;&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;
      
    
    </summary>
    
    
      <category term="日常题目" scheme="https://liu-zhou-l.github.io/categories/%E6%97%A5%E5%B8%B8%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="dp" scheme="https://liu-zhou-l.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>5月22日动态规划阶段测试</title>
    <link href="https://liu-zhou-l.github.io/posts/f81a7ae9/"/>
    <id>https://liu-zhou-l.github.io/posts/f81a7ae9/</id>
    <published>2020-05-23T12:01:54.000Z</published>
    <updated>2023-09-21T08:20:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题-0X00"><a href="#题-0X00" class="headerlink" title="题 0X00"></a>题 0X00</h1><h2 id="题目传送门"><a href="#题目传送门" class="headerlink" title="题目传送门"></a>题目传送门</h2><p><a href="http://codeforces.com/problemset/problem/1324/E" target="_blank" rel="noopener">CF1324E Sleeping Schedule</a></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这个题由于每次都需要选择，是在ai-1时睡还是ai时睡，那么很明显，这个题需要用动态规划来写。</p><p>对于所有的动态规划问题，我们首先都是找他们的关系式。</p><p>对于这个题而言，对答案的影响是在于小明在[l,r]这段时间内入睡的次数，那么，我们就设一个数组 $ dp[i][j] $ ，表示小明的第i次睡眠在第j小时开始入睡能够获得的最大的 $ ans $ 。那么，由于小明睡觉的时间有两种情况，因此，我们就可以直接进行分类讨论：</p><p>如果小明选择过 $ a_i $ 这么多时间睡觉，那么：</p><p>如果 $ (j + a[i]) % h &gt;= l $ 并且  $ (j + a[i]) % h &lt;= r $ ,那么有 $ dp[i][(j + a[i]) % h]=max{dp[i - 1][j] + 1} $<br>否则，则有 $ dp[i][(j + a[i]) % h] = max{dp[i - 1][j]} $ </p><p>如果小明选择过 $ a_i-1 $ 这么多时间睡觉，那么：</p><p>如果 $ (j + a[i] - 1) % h &gt;= l $ 并且  $ (j + a[i] - 1) % h &lt;= r $ ,那么有 $ dp[i][(j + a[i] - 1) % h]=max{dp[i - 1][j] + 1} $<br>否则，则有 $ dp[i][(j + a[i] - 1) % h] = max{dp[i - 1][j]} $ </p><p>最后的答案就是 $ dp[n][i] $ 中最大的那个。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, h, l, r, a[MAXN], sum = <span class="number">0</span>, f[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//freopen("sleep.in", "r", stdin);</span></span><br><span class="line"><span class="comment">//freopen("sleep.out", "w", stdout);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;h, &amp;l, &amp;r);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-0x3f3f3f3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; h; j ++) &#123;</span><br><span class="line"><span class="keyword">if</span>((j + a[i]) % h &gt;=l &amp;&amp; (j + a[i]) % h &lt;= r) &#123;</span><br><span class="line">f[i][(j + a[i]) % h] = max(f[i][(j + a[i]) % h], f[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">f[i][(j + a[i]) % h] = max(f[i][(j + a[i]) % h], f[i<span class="number">-1</span>][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>((j + a[i] - <span class="number">1</span>) % h &gt;= l &amp;&amp; (j + a[i] - <span class="number">1</span>) % h &lt;= r) &#123;</span><br><span class="line">f[i][(j + a[i] - <span class="number">1</span>) % h] = max(f[i][(j + a[i] - <span class="number">1</span>) % h], f[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">f[i][(j + a[i] - <span class="number">1</span>) % h] = max(f[i][(j + a[i] - <span class="number">1</span>) % h], f[i - <span class="number">1</span>][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= h; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span>(f[n][i] &gt; sum) &#123;</span><br><span class="line">sum = f[n][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有图证AC<br><img src="/images/批注 2020-05-23 200041.jpg" alt=""></p><h1 id="题-0X01"><a href="#题-0X01" class="headerlink" title="题 0X01"></a>题 0X01</h1><h2 id="题目传送门-1"><a href="#题目传送门-1" class="headerlink" title="题目传送门"></a>题目传送门</h2><p><a href="http://codeforces.com/problemset/problem/628/B" target="_blank" rel="noopener">Codeforces 628B</a></p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>由于我们知道，$ 100 $ 是 $ 4 $ 的倍数，那么，对于一个大于 $ 100 $ 的数字，只需要判断这个数字的最小的两位组成的数字能否被 $ 4 $ 整除即可。因此，我们只需要</p><ol><li>首先判断第一个数是不是 $ 4 $ 的倍数，如果是就加 $ 1 $ 。</li><li>从第二位开始，如果第 $ i $ 位数能被 $ 4 $ 整除，答案 $ +1 $ ，如果以 $ i $ 和 $ i-1 $ 位的两个数字组成的两位数是 $ 4 $ 的倍数，那么答案就 $ +i $ （比如 $ 124 $ ，首先是 $ 1 $ ，不是 $ 4 $ 的倍数，就不管，然后是 $ 12 $ , $ 2 $ 不是 $ 4 $ 的倍数，但是 $ 12 $ 是，所以答案就加上 $ i=1 $ ，然后是 $ 124 $ ，因为 $ 4 $ 是 $ 4 $ 的倍数，所以答案 $ +1=2 $ ，然后 $ 24 $ 也是 $ 4 $ 的倍数，所以答案 $ +2=4 $ ）。</li></ol><h2 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3</span> * <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>, len, a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//freopen("four.in", "r", stdin);</span></span><br><span class="line"><span class="comment">//freopen("four.out", "w", stdout);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);</span><br><span class="line">len = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = len; i &gt;= <span class="number">1</span>; i --) &#123;</span><br><span class="line">a[i] = str[len - i] - <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span>(a[i] % <span class="number">4</span> == <span class="number">0</span>) &#123;</span><br><span class="line">sum ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i &lt; len &amp;&amp; (a[i] + a[i + <span class="number">1</span>] * <span class="number">10</span>) % <span class="number">4</span> == <span class="number">0</span>) &#123;</span><br><span class="line">sum += len - i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>, sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题-0X02"><a href="#题-0X02" class="headerlink" title="题 0X02"></a>题 0X02</h1><h2 id="题目传送门-2"><a href="#题目传送门-2" class="headerlink" title="题目传送门"></a>题目传送门</h2><p><a href="https://codeforces.com/problemset/problem/1207/C" target="_blank" rel="noopener">Codeforces 1207C</a></p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>一看到这种有选择的题，就知道要么是搜索，要么是DP。由于这个题每个状态都只和相邻的状态有关，因此，这个题也是用DP来做。</p><p>我们设 $ dp[i][j] $ 表示第 $ i $ 个路口右边的支柱为 $ j $ 这么高的所需要的最小花费。<br>如果这个路口是 $ 1 $ ，那么，此时右边和左边的支柱就只能是高度为 $ 2 $ 的支柱。<br>于是就有：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">1</span>]=max&#123;dp[i<span class="number">-1</span>][<span class="number">1</span>]+a+<span class="number">2b</span>&#125;</span><br></pre></td></tr></table></figure><br>如果这个路口是 $ 0 $ ，那么，右边的支柱可以是高支柱，也可以是矮支柱。<br>如果右边的支柱是矮支柱，那么：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>]=max&#123;min(dp[i<span class="number">-1</span>][<span class="number">0</span>]+a+b,dp[i<span class="number">-1</span>][<span class="number">1</span>]+<span class="number">2</span>a+b)&#125;</span><br></pre></td></tr></table></figure><br>如果是高支柱，那么：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">1</span>]=max&#123;min(dp[i<span class="number">-1</span>][<span class="number">0</span>]+<span class="number">2</span>a+<span class="number">2b</span>,dp[i<span class="number">-1</span>][<span class="number">1</span>]+a+<span class="number">2b</span>)&#125;</span><br></pre></td></tr></table></figure><br>由于最后一个路口一定是 $ 0 $ ，所以最后答案直接输出 $ dp[n][0] $ 。<br>另外考虑到有些不会出现的情况，为了不影响我们的答案，所以所有的数据初始化为 $ INF $ 。</p><h2 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2</span> * <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> t, n, a, b, f[MAXN][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">char</span> dl[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;t);</span><br><span class="line"><span class="keyword">while</span>(t --) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld\n"</span>, &amp;n, &amp;a, &amp;b);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;dl[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = b;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span>(dl[i] == <span class="string">'1'</span>) &#123;</span><br><span class="line">f[i][<span class="number">1</span>] = min(f[i][<span class="number">1</span>], f[i - <span class="number">1</span>][<span class="number">1</span>] + a + <span class="number">2</span> * b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">f[i][<span class="number">0</span>] = min(f[i][<span class="number">0</span>], min(f[i - <span class="number">1</span>][<span class="number">0</span>] + a + b, f[i - <span class="number">1</span>][<span class="number">1</span>] + <span class="number">2</span> * a + b));</span><br><span class="line">f[i][<span class="number">1</span>] = min(f[i][<span class="number">1</span>], min(f[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">2</span> * a + <span class="number">2</span> * b, f[i - <span class="number">1</span>][<span class="number">1</span>] + a + b * <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[n][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题-0X01-1"><a href="#题-0X01-1" class="headerlink" title="题 0X01"></a>题 0X01</h1><h2 id="题目传送门-3"><a href="#题目传送门-3" class="headerlink" title="题目传送门"></a>题目传送门</h2><p><a href="http://codeforces.com/problemset/problem/628/B" target="_blank" rel="noopener">Codeforces 628B</a></p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>由于我们知道，$ 100 $ 是 $ 4 $ 的倍数，那么，对于一个大于 $ 100 $ 的数字，只需要判断这个数字的最小的两位组成的数字能否被 $ 4 $ 整除即可。因此，我们只需要</p><ol><li>首先判断第一个数是不是 $ 4 $ 的倍数，如果是就加 $ 1 $ 。</li><li>从第二位开始，如果第 $ i $ 位数能被 $ 4 $ 整除，答案 $ +1 $ ，如果以 $ i $ 和 $ i-1 $ 位的两个数字组成的两位数是 $ 4 $ 的倍数，那么答案就 $ +i $ （比如 $ 124 $ ，首先是 $ 1 $ ，不是 $ 4 $ 的倍数，就不管，然后是 $ 12 $ , $ 2 $ 不是 $ 4 $ 的倍数，但是 $ 12 $ 是，所以答案就加上 $ i=1 $ ，然后是 $ 124 $ ，因为 $ 4 $ 是 $ 4 $ 的倍数，所以答案 $ +1=2 $ ，然后 $ 24 $ 也是 $ 4 $ 的倍数，所以答案 $ +2=4 $ ）。</li></ol><h2 id="AC代码-3"><a href="#AC代码-3" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3</span> * <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>, len, a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//freopen("four.in", "r", stdin);</span></span><br><span class="line"><span class="comment">//freopen("four.out", "w", stdout);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);</span><br><span class="line">len = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = len; i &gt;= <span class="number">1</span>; i --) &#123;</span><br><span class="line">a[i] = str[len - i] - <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span>(a[i] % <span class="number">4</span> == <span class="number">0</span>) &#123;</span><br><span class="line">sum ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i &lt; len &amp;&amp; (a[i] + a[i + <span class="number">1</span>] * <span class="number">10</span>) % <span class="number">4</span> == <span class="number">0</span>) &#123;</span><br><span class="line">sum += len - i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>, sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题-0X02-1"><a href="#题-0X02-1" class="headerlink" title="题 0X02"></a>题 0X02</h1><h2 id="题目传送门-4"><a href="#题目传送门-4" class="headerlink" title="题目传送门"></a>题目传送门</h2><p><a href="https://codeforces.com/problemset/problem/1207/C" target="_blank" rel="noopener">Codeforces 1207C</a></p><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>一看到这种有选择的题，就知道要么是搜索，要么是DP。由于这个题每个状态都只和相邻的状态有关，因此，这个题也是用DP来做。</p><p>我们设 $ dp[i][j] $ 表示第 $ i $ 个路口右边的支柱为 $ j $ 这么高的所需要的最小花费。<br>如果这个路口是 $ 1 $ ，那么，此时右边和左边的支柱就只能是高度为 $ 2 $ 的支柱。<br>于是就有：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">1</span>]=max&#123;dp[i<span class="number">-1</span>][<span class="number">1</span>]+a+<span class="number">2b</span>&#125;</span><br></pre></td></tr></table></figure><br>如果这个路口是 $ 0 $ ，那么，右边的支柱可以是高支柱，也可以是矮支柱。<br>如果右边的支柱是矮支柱，那么：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>]=max&#123;min(dp[i<span class="number">-1</span>][<span class="number">0</span>]+a+b,dp[i<span class="number">-1</span>][<span class="number">1</span>]+<span class="number">2</span>a+b)&#125;</span><br></pre></td></tr></table></figure><br>如果是高支柱，那么：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">1</span>]=max&#123;min(dp[i<span class="number">-1</span>][<span class="number">0</span>]+<span class="number">2</span>a+<span class="number">2b</span>,dp[i<span class="number">-1</span>][<span class="number">1</span>]+a+<span class="number">2b</span>)&#125;</span><br></pre></td></tr></table></figure><br>由于最后一个路口一定是 $ 0 $ ，所以最后答案直接输出 $ dp[n][0] $ 。<br>另外考虑到有些不会出现的情况，为了不影响我们的答案，所以所有的数据初始化为 $ INF $ 。</p><h2 id="AC代码-4"><a href="#AC代码-4" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2</span> * <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> t, n, a, b, f[MAXN][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">char</span> dl[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;t);</span><br><span class="line"><span class="keyword">while</span>(t --) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld\n"</span>, &amp;n, &amp;a, &amp;b);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;dl[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = b;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span>(dl[i] == <span class="string">'1'</span>) &#123;</span><br><span class="line">f[i][<span class="number">1</span>] = min(f[i][<span class="number">1</span>], f[i - <span class="number">1</span>][<span class="number">1</span>] + a + <span class="number">2</span> * b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">f[i][<span class="number">0</span>] = min(f[i][<span class="number">0</span>], min(f[i - <span class="number">1</span>][<span class="number">0</span>] + a + b, f[i - <span class="number">1</span>][<span class="number">1</span>] + <span class="number">2</span> * a + b));</span><br><span class="line">f[i][<span class="number">1</span>] = min(f[i][<span class="number">1</span>], min(f[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">2</span> * a + <span class="number">2</span> * b, f[i - <span class="number">1</span>][<span class="number">1</span>] + a + b * <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[n][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题-0X00&quot;&gt;&lt;a href=&quot;#题-0X00&quot; class=&quot;headerlink&quot; title=&quot;题 0X00&quot;&gt;&lt;/a&gt;题 0X00&lt;/h1&gt;&lt;h2 id=&quot;题目传送门&quot;&gt;&lt;a href=&quot;#题目传送门&quot; class=&quot;headerlink&quot; title=&quot;题目传送门&quot;&gt;&lt;/a&gt;题目传送门&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://codeforces.com/problemset/problem/1324/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CF1324E Sleeping Schedule&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h2&gt;&lt;p&gt;这个题由于每次都需要选择，是在ai-1时睡还是ai时睡，那么很明显，这个题需要用动态规划来写。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>乌龟棋</title>
    <link href="https://liu-zhou-l.github.io/posts/2e6c9d1e/"/>
    <id>https://liu-zhou-l.github.io/posts/2e6c9d1e/</id>
    <published>2020-05-23T10:38:00.000Z</published>
    <updated>2023-09-21T08:20:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目传送门"><a href="#题目传送门" class="headerlink" title="题目传送门"></a>题目传送门</h1><p><a href="https://www.luogu.com.cn/problem/P1541" target="_blank" rel="noopener">luogu</a></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p><del>暴力的来看</del> 这道题用动态规划求解，则可以定义状态 $ f[i][j][k][l] $ ，表示使用了 $ i $ 张 $ a $ 卡片, $ j $ 张 $ b $ 卡片, $ k $ 张 $ c $ 卡片, $ l $ 张 $ d $ 卡片后可以获得的最大分数，可以将它理解为一个多维的走楼梯问题，每次有 $ 4 $ 种走法</p><p>状态转移方程如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i != <span class="number">0</span>) dp[i][j][l][k] = max(dp[i][j][l][k], dp[i - <span class="number">1</span>][j][l][k] + s[t]);</span><br><span class="line"><span class="comment">// s数组储存的棋盘对应的每个位置的分数</span></span><br><span class="line"><span class="keyword">if</span>(j != <span class="number">0</span>) dp[i][j][l][k] = max(dp[i][j][l][k], dp[i][j - <span class="number">1</span>][l][k] + s[t]);</span><br><span class="line"><span class="keyword">if</span>(l != <span class="number">0</span>) dp[i][j][l][k] = max(dp[i][j][l][k], dp[i][j][l - <span class="number">1</span>][k] + s[t]);</span><br><span class="line"><span class="keyword">if</span>(k != <span class="number">0</span>) dp[i][j][l][k] = max(dp[i][j][l][k], dp[i][j][l][k - <span class="number">1</span>] + s[t]);</span><br></pre></td></tr></table></figure></p><h1 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">355</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, card[<span class="number">10</span>], a[MAXN], f[<span class="number">45</span>][<span class="number">45</span>][<span class="number">45</span>][<span class="number">45</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;temp);</span><br><span class="line">card[temp] ++;</span><br><span class="line">&#125; </span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = a[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= card[<span class="number">1</span>]; i ++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= card[<span class="number">2</span>]; j ++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= card[<span class="number">3</span>]; k ++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= card[<span class="number">4</span>]; l ++) &#123;</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">1</span> + i + j * <span class="number">2</span> + k * <span class="number">3</span> + l * <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span>) f[i][j][k][l] = max(f[i][j][k][l], f[i - <span class="number">1</span>][j][k][l] + a[t]); </span><br><span class="line">                <span class="keyword">if</span>(j &gt; <span class="number">0</span>) f[i][j][k][l] = max(f[i][j][k][l], f[i][j - <span class="number">1</span>][k][l] + a[t]);</span><br><span class="line">                <span class="keyword">if</span>(k &gt; <span class="number">0</span>) f[i][j][k][l] = max(f[i][j][k][l], f[i][j][k - <span class="number">1</span>][l] + a[t]);</span><br><span class="line">                <span class="keyword">if</span>(l &gt; <span class="number">0</span>) f[i][j][k][l] = max(f[i][j][k][l], f[i][j][k][l - <span class="number">1</span>] + a[t]);</span><br><span class="line"><span class="comment">//f[i][j][k][l] += a[(i + j * 2 + k * 3 + l * 4 + 1)];</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d"</span>, f[card[<span class="number">1</span>]][card[<span class="number">2</span>]][card[<span class="number">3</span>]][card[<span class="number">4</span>]]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目传送门&quot;&gt;&lt;a href=&quot;#题目传送门&quot; class=&quot;headerlink&quot; title=&quot;题目传送门&quot;&gt;&lt;/a&gt;题目传送门&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P1541&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;luogu&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h1&gt;&lt;p&gt;&lt;del&gt;暴力的来看&lt;/del&gt; 这道题用动态规划求解，则可以定义状态 $ f[i][j][k][l] $ ，表示使用了 $ i $ 张 $ a $ 卡片, $ j $ 张 $ b $ 卡片, $ k $ 张 $ c $ 卡片, $ l $ 张 $ d $ 卡片后可以获得的最大分数，可以将它理解为一个多维的走楼梯问题，每次有 $ 4 $ 种走法&lt;/p&gt;
&lt;p&gt;状态转移方程如下&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="日常题目" scheme="https://liu-zhou-l.github.io/categories/%E6%97%A5%E5%B8%B8%E9%A2%98%E7%9B%AE/"/>
    
    
      <category term="dp" scheme="https://liu-zhou-l.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>最长上升子序列(LIS)详解</title>
    <link href="https://liu-zhou-l.github.io/posts/6e153245/"/>
    <id>https://liu-zhou-l.github.io/posts/6e153245/</id>
    <published>2020-05-17T01:20:55.000Z</published>
    <updated>2023-09-21T08:20:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><blockquote><p>最长上升子序列（Longest Increasing Subsequence，LIS），在计算机科学上是指一个序列中最长的单调递增的子序列。</p><p align="right">引自百度百科</p></blockquote><h1 id="状态与状态转移方程"><a href="#状态与状态转移方程" class="headerlink" title="状态与状态转移方程"></a>状态与状态转移方程</h1><p>最长上升子序列是序列，其状态是一维的，所以我们可以定义状态 f(i),表示以a[i]结尾的最长上升子序列</p><p>如果每一个元素都只考虑它本身，则以a[i]结尾的最长上升子序列长度为一，即它本身，则初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[i] &#x3D; 1</span><br></pre></td></tr></table></figure></p><p>如果a[i]比a[j]大（i&gt;j），则a[i]可以添加到以a[j]结尾的最长上升子序列的末尾，即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[i] &#x3D; max(f[i], f[j] + 1)</span><br></pre></td></tr></table></figure></p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN], f[MAXN], n, ans = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">f[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j ++) &#123;</span><br><span class="line"><span class="keyword">if</span>(a[i] &gt; a[j] &amp;&amp; f[j] + <span class="number">1</span> &gt; f[i]) &#123;</span><br><span class="line">f[i] = f[j] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ans &lt; f[i]) &#123;</span><br><span class="line">ans = f[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;最长上升子序列（Longest Increasing Subsequence，LIS），在计算机科学上是指一个序列中最长的单调递增的子序列。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;引自百度百科&lt;/p&gt;

&lt;/blockquote&gt;
&lt;h1 id=&quot;状态与状态转移方程&quot;&gt;&lt;a href=&quot;#状态与状态转移方程&quot; class=&quot;headerlink&quot; title=&quot;状态与状态转移方程&quot;&gt;&lt;/a&gt;状态与状态转移方程&lt;/h1&gt;&lt;p&gt;最长上升子序列是序列，其状态是一维的，所以我们可以定义状态 f(i),表示以a[i]结尾的最长上升子序列&lt;/p&gt;
&lt;p&gt;如果每一个元素都只考虑它本身，则以a[i]结尾的最长上升子序列长度为一，即它本身，则初始化&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>最长上升子序列(LIS)nlogn算法</title>
    <link href="https://liu-zhou-l.github.io/posts/bf0d03cd/"/>
    <id>https://liu-zhou-l.github.io/posts/bf0d03cd/</id>
    <published>2020-05-16T10:41:38.000Z</published>
    <updated>2023-09-21T08:20:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200513140620345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdV96aG91X3pob3U=,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>替换其实是为后面的元素让出更多的空间，如果有更小的元素，才能插入，如果没有，则对最终结果也没有影响</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x, f[MAXN], n, ans = <span class="number">1</span>;<span class="comment">//f为答案序列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">f[i] = x;</span><br><span class="line"><span class="keyword">if</span>(x &gt; f[ans]) &#123;</span><br><span class="line">f[++ans] = x;<span class="comment">//如果小于最后一个元素，插入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> ind = lower_bound(f + <span class="number">1</span>, f + <span class="number">1</span> + ans, x) - f;<span class="comment">//否则，找到第一个大于等于其的元素，进行替换</span></span><br><span class="line">f[ind] = x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200513140620345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Windows平台搭建Minecraft的Java版服务器</title>
    <link href="https://liu-zhou-l.github.io/posts/2202222a/"/>
    <id>https://liu-zhou-l.github.io/posts/2202222a/</id>
    <published>2020-05-02T00:54:00.000Z</published>
    <updated>2023-09-21T08:20:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>需要两个东西，Java环境和开服包</p><p><a href="https://www.java.com/zh_CN/" target="_blank" rel="noopener">Java8官网链接</a><br><a href="https://mcversions.net/" target="_blank" rel="noopener">官方开服包链接</a></p><h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><p>在命令行输入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><br>如果出现类似下面的输出，则Java已安装成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java version &quot;1.8.0_251&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_251-b08)</span><br><span class="line">Java HotSpot(TM) Client VM (build 25.251-b08, mixed mode, sharing)</span><br></pre></td></tr></table></figure></p><h2 id="搭建服务器"><a href="#搭建服务器" class="headerlink" title="搭建服务器"></a>搭建服务器</h2><p>安装完成Java后，将开服包放在合适的目录下，开始以下的步骤</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在服务器目录下新建start.cmd（将用来启动服务器）<br>在其中输入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">java -Xms1g -Xmx1g -jar server.jar</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><br>双击启动服务器<br><img src="https://s1.ax1x.com/2020/05/02/JjRLqS.jpg" style="zoom:70%"><br>关闭窗口，然后进入euls.txt文件，将false修改为true<br><img src="https://s1.ax1x.com/2020/05/02/JjWuxx.jpg" style="zoom:70%"><br>完成后进入server.properties文件，参考以下内容对游戏设置进行编辑<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#服务器基本设置</span><br><span class="line">level-name &#x3D; 服务器名称(这里必须使用英文)</span><br><span class="line">hellworld &#x3D; 地狱世界(true&#x3D;开启 false&#x3D;关闭)</span><br><span class="line">spawn-monsters &#x3D; 生成怪物(true&#x3D;开启 false&#x3D;关闭)</span><br><span class="line">spawn-animals &#x3D; 生成动物(true&#x3D;开启 false&#x3D;关闭)</span><br><span class="line">online-mode &#x3D; 在线模式(盗版服请设false)</span><br><span class="line">max-players &#x3D; 服务器上限人数(好友不多的建议10 否则设置多少消耗多少内存)</span><br><span class="line">server-ip &#x3D; 用于绑定服务器地址(建议留空 Hamachi例外)</span><br><span class="line">pvp &#x3D; 友军伤害(true&#x3D;开启 false&#x3D;关闭)</span><br><span class="line">server-port &#x3D; 服务器端口</span><br><span class="line">white-list &#x3D; 启用黑名单,在banned-players插入玩家名</span><br><span class="line"></span><br><span class="line">#服务器隐藏设置</span><br><span class="line">verify-names &#x3D; 检测昵称,第一个重名昵称将被kick</span><br><span class="line">spawn-protection &#x3D; 重生点保护范围(单位:格 如32及32x32)</span><br><span class="line">levelName &#x3D; 服务器名称</span><br><span class="line">onlineMode &#x3D; 在线模式</span><br><span class="line">autoSave &#x3D; 自动保存</span><br><span class="line">autoSaveMins &#x3D; 服务器自动保存时间(单位:秒)</span><br><span class="line">autoBackup &#x3D; 自动备份</span><br><span class="line">autoBackupMins &#x3D; 自动备份时间(单位:秒)</span><br><span class="line">keepBackupHours &#x3D; 保留备份时间,超过将删除备份(单位:天)</span><br><span class="line">autoRestart &#x3D; 自动重启(服务端检测到错误时)</span><br><span class="line">autoRestartMins &#x3D; 自动重启时间(单位:秒)</span><br><span class="line">exitOnFailure &#x3D; 退出失效(未知)</span><br><span class="line">port &#x3D; 端口</span><br><span class="line">internalPort &#x3D; 内部端口</span><br><span class="line">rconPort &#x3D; 远程端口</span><br><span class="line">rconPassword &#x3D; 远程密码</span><br><span class="line">useWhitelist &#x3D; 是否启用特定的人才可加入服务器</span><br><span class="line">useSMPAPI &#x3D; 使用多核处理</span><br><span class="line">c10tArgs &#x3D; 是用C10T参数(好像是10进制的意思)</span><br><span class="line">c10tMins &#x3D; C10T处理时间(单位:秒)</span><br><span class="line">maxPlayers &#x3D; 同max-players</span><br><span class="line">defaultGroup &#x3D; 默认组(此为Steam组,盗版无视)</span><br><span class="line">useSlashes &#x3D; 使用斜杠语法(默认dots语法)</span><br><span class="line">memory &#x3D; 内存(及服务端最高吃多少内存)</span><br><span class="line">useMsgFormats &#x3D; 使用信息格式(未知)</span><br><span class="line">msgTitleFormat &#x3D; 信息标题格式</span><br><span class="line">msgFormat &#x3D; 信息格式</span><br><span class="line">localChatRadius &#x3D; 当地信息交互(AAA协议)</span><br><span class="line">debug &#x3D; 调试模式</span><br><span class="line">alternateJarFile &#x3D; 备用的jar文件(建议留空)</span><br><span class="line">guestsCanViewComplex &#x3D; 来宾可以查看(Complex好像是函数)</span><br><span class="line">ipAddress &#x3D; IP地址(建议留空)</span><br><span class="line">javaArguments &#x3D; Java参数</span><br></pre></td></tr></table></figure></p><p><strong>盗版客户端请将online-mode设为false</strong></p><p>至此，服务器配置完成。</p><h3 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h3><p>双击start.cmd即可启动服务器<br>关闭服务器请在命令行窗口输入stop</p><h3 id="使用端口映射在公网上联机"><a href="#使用端口映射在公网上联机" class="headerlink" title="使用端口映射在公网上联机"></a>使用端口映射在公网上联机</h3><p>端口映射软件推荐使用免费的Sakura Frp<br><a href="https://www.natfrp.com/" target="_blank" rel="noopener">官网链接</a></p><p>打开软件选择服务器的端口进行映射即可  </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h2&gt;&lt;p&gt;需要两个东西，Java环境和开服包&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.java.com/zh_CN/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java8官网链接&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://mcversions.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方开服包链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;检查&quot;&gt;&lt;a href=&quot;#检查&quot; class=&quot;headerlink&quot; title=&quot;检查&quot;&gt;&lt;/a&gt;检查&lt;/h2&gt;&lt;p&gt;在命令行输入以下代码：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>水文</title>
    <link href="https://liu-zhou-l.github.io/posts/aa01fe8/"/>
    <id>https://liu-zhou-l.github.io/posts/aa01fe8/</id>
    <published>2020-05-02T00:31:27.000Z</published>
    <updated>2023-09-21T08:20:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快乐五一，充实五一，劳动五一"><a href="#快乐五一，充实五一，劳动五一" class="headerlink" title="快乐五一，充实五一，劳动五一"></a>快乐五一，充实五一，劳动五一</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;快乐五一，充实五一，劳动五一&quot;&gt;&lt;a href=&quot;#快乐五一，充实五一，劳动五一&quot; class=&quot;headerlink&quot; title=&quot;快乐五一，充实五一，劳动五一&quot;&gt;&lt;/a&gt;快乐五一，充实五一，劳动五一&lt;/h1&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>树的概念和定义</title>
    <link href="https://liu-zhou-l.github.io/posts/5ccfd6f3/"/>
    <id>https://liu-zhou-l.github.io/posts/5ccfd6f3/</id>
    <published>2020-04-12T01:33:00.000Z</published>
    <updated>2023-09-21T08:20:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="https://s1.ax1x.com/2020/04/12/GqWaTg.png" alt="" title="图1 树"></p><blockquote><p>上物，谓之树焉</p></blockquote><hr><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>树是n（n≥0）个结点的有限集合T(Tree)。当n=0时，称为空树(<strong>其也是树</strong>)；当n&gt;0时， 该集合满足如下条件：</p><ul><li>其中必有一个称为根（root）的特定结点，它没有直接前驱，但有零个或多个直接后继。 </li><li>其余n-1个结点可以划分成m（m≥0）个互不相交的有限集T1，T2，T3，…，Tm，其中Ti又是一棵树，称为根root的子树。 每棵子树的根结点有且仅有一个直接前驱，但有零个或多个直接后继。</li></ul><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul><li>结点：包含一个数据元素及若干指向其它结点的分支信息。</li><li>结点的度：一个结点的子树个数称为此结点的度。</li><li>叶结点：度为0的结点，即无后继的结点，也称为终端结点。</li><li>分支结点：度不为0的结点，也称为非终端结点。</li><li>孩子结点：一个结点的直接后继称为该结点的孩子结点。</li><li>双亲结点：一个结点的直接前驱称为该结点的双亲结点。</li><li>兄弟结点：同一双亲结点的孩子结点之间互称兄弟结点。</li><li>祖先结点：一个结点的祖先结点是指从根结点到该结点的路径上的所有结点。在图1中，结点K的祖先是A、B、E。</li><li>子孙结点：一个结点的直接后继和间接后继称为该结点的子孙结点。在图1中，结点D的子孙是H、I、 J、 M。</li><li>树的度： 树中所有结点的度的最大值。</li><li>结点的层次：从根结点开始定义，根结点的层次为1，根的直接后继的层次为2，依此类推。</li><li>树的高度（深度）： 树中所有结点的层次的最大值。</li><li>有序树：在树T中，如果各子树Ti之间是有先后次序的，则称为有序树。</li><li>森林： m（m≥0）棵互不相交的树的集合。将一棵非空树的根结点删去，树就变成一个森林；反之，给森林增加一个统一的根结点，森林就变成一棵树。</li></ul><hr><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><p>定义：我们把满足以下两个条件的树形结构叫做二叉树（Binary Tree）： </p><ul><li>每个结点的度都不大于2；</li><li>每个结点的孩子结点次序不能任意颠倒。</li></ul><p>由此定义可以看出，一个二叉树中的每个结点只能含有0、 1或2个孩子（<strong>条件一</strong>），而且每个孩子有左右之分（<strong>条件二</strong>）。我们把位于左边的孩子叫做左孩子，位于右边的孩子叫做右孩子。 </p><h3 id="二叉树的基本形态"><a href="#二叉树的基本形态" class="headerlink" title="二叉树的基本形态"></a>二叉树的基本形态</h3><p>由二叉树的定义我们可知，二叉树应有以下五种基本形态（<strong>注意是左右子树</strong>）：<br><img src="https://s1.ax1x.com/2020/04/12/GLj7y8.png" alt="" title="图2 二叉树的五种基本形态"></p><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><hr><h4 id="二叉树的性质1"><a href="#二叉树的性质1" class="headerlink" title="二叉树的性质1"></a>二叉树的性质1</h4><blockquote><p>在二叉树的第i层上至多有 2<sup>i-1</sup> 个结点(i≥1)。</p></blockquote><h5 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h5><p>采用数学归纳法证明。 </p><ul><li>归纳基础：当i=1时，整个二叉树只有一根结点，此时2<sup>i-1</sup>=2<sup>0</sup>=1，结论成立。</li><li>归纳假设：假设i=k时结论成立，即第k层上结点总数最多为2<sup>k-1</sup>个。</li></ul><p>现证明当i=k+1时， 结论成立：</p><p>因为二叉树中每个结点的度最大为2，则第k+1层的结点总数最多为第k层上结点最大数的2倍，即2×2<sup>k-1</sup>=2<sup>(k+1)-1</sup>，故结论成立。</p><hr><h4 id="二叉树的性质2"><a href="#二叉树的性质2" class="headerlink" title="二叉树的性质2"></a>二叉树的性质2</h4><blockquote><p>深度为k的二叉树至多有2<sup>k</sup>-1个结点（k≥1）。</p></blockquote><h5 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h5><p>因为深度为k的二叉树，其结点总数的最大值是将二叉树每层上结点的最大值相加，所以深度为k的二叉树的结点总数至多为<br><img src="https://s1.ax1x.com/2020/04/12/GLxcUH.png" style="zoom:30%"><br>故结论成立。</p><hr><h4 id="二叉树的性质3"><a href="#二叉树的性质3" class="headerlink" title="二叉树的性质3"></a>二叉树的性质3</h4><blockquote><p>对任意一棵二叉树T，若终端结点数为n<sub>0</sub>，而其度数为2的结点数为n<sub>2</sub>，则n<sub>0</sub>=n<sub>2</sub>+1。</p></blockquote><h5 id="证明-2"><a href="#证明-2" class="headerlink" title="证明"></a>证明</h5><p>设二叉树中结点总数为n， n1为二叉树中度为1的结点总数。<br>因为二叉树中所有结点的度小于等于2，所以有</p><blockquote><p>n=n<sub>0</sub>+n<sub>2</sub>+n<sub>2</sub>  </p></blockquote><p>设二叉树中分支数目为B(其实就是边数)， 因为除根结点外， 每个结点均对应一个进入它的分支，所以有</p><blockquote><p>n=B+1</p></blockquote><p>又因为二叉树中的分支都是由度为1和度为2的结点发出， 所以分支数目为</p><blockquote><p>B=n<sub>1</sub>+2n<sub>2</sub></p></blockquote><p>整理上述两式可得到</p><blockquote><p>n=B+1=n<sub>1</sub>+2n<sub>2</sub>+1</p></blockquote><p>将n=n<sub>0</sub>+n1<sub>1</sub>+n<sub>2</sub>代入上式，得出n<sub>0</sub>+n<sub>1</sub>+n<sub>2</sub>=n<sub>1</sub>+2n<sub>2</sub>+1，整理后得n<sub>0</sub>=n<sub>2</sub>+1，故结论成立。 </p><hr><h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2><p>深度为k且有2k-1个结点的二叉树。在满二叉树中，每层结点都是满的，即每层结点都具有最大结点数。 图3(a)所示的二叉树，即为一棵满二叉树。<br>满二叉树的顺序表示，即从二叉树的根开始， 层间从上到下， 层内从左到右，逐层进行编号（1， 2， …， n）。例如图3(a)所示的满二叉树的顺序表示为(1， 2， 3， 4， 5， 6， 7， 8， 9， 10， 11， 12， 13， 14， 15)。<br><img src="https://s1.ax1x.com/2020/04/12/GOpd8s.png" alt="" title="图3 满二叉树与完全二叉树"></p><hr><h4 id="二叉树的性质4"><a href="#二叉树的性质4" class="headerlink" title="二叉树的性质4"></a>二叉树的性质4</h4><blockquote><p>具有n个结点的完全二叉树的深度为int(log<sub>2</sub>n)+1。 </p></blockquote><h5 id="证明-3"><a href="#证明-3" class="headerlink" title="证明"></a>证明</h5><p>假设n个结点的完全二叉树的深度为k，根据性质2可知，k-1层满二叉树的结点总数为  </p><blockquote><p>n<sub>1</sub>=2<sup>k-1</sup>-1</p></blockquote><p>k层满二叉树的结点总数为</p><blockquote><p>n<sub>2</sub>=2<sup>k</sup>-1</p></blockquote><p>显然有n<sub>1</sub><n≤n<sub>2&lt;/sub&gt;，进一步可以推出n<sub>1</sub>+1≤n<n<sub>2&lt;/sub&gt;+1。<br>将n<sub>1</sub>=2<sup>k-1</sup>-1和n<sub>2</sub>=2<sup>k</sup>-1代入上式，可得2<sup>k-1</sup>≤n<2<sup>k&lt;/sup&gt;，即k-1≤log<sub>2</sub>n<k 因为k是整数，所以k-1=int(log<sub>2&lt;/sub&gt;n)，k=int(log<sub>2</sub>n)+1, 故结论成立。</p><hr><h4 id="二叉树的性质5"><a href="#二叉树的性质5" class="headerlink" title="二叉树的性质5"></a>二叉树的性质5</h4><blockquote><p>对于具有n个结点的完全二叉树， 如果按照从上到                   下和从左到右的顺序对二叉树中的所有结点从1开始顺序编号， 则对于任意的序号为i的结点有：</p><p>（1） 如i=1，则序号为i的结点是根结点， 无双亲结点； 如i&gt;1， 则序号为i的结点的双亲结点序号为int(i/2)。</p><p>（2） 如2×i&gt;n，则序号为i的结点无左孩子；如2×i≤n，则序号为i的结点的左孩子结点的序号为2×i。 </p><p>（3） 如2×i＋1&gt;n，则序号为i的结点无右孩子；如2×i＋1≤n， 则序号为i的结点的右孩子结点的序号为2×i＋1。 </p></blockquote><h5 id="证明-4"><a href="#证明-4" class="headerlink" title="证明"></a>证明</h5><p>可以用归纳法证明其中的（2）和（3）：</p><p>当i=1时，由完全二叉树的定义知，如果2×i=2≤n，说明二叉树中存在两个或两个以上的结点，所以其左孩子存在且序号为2； 反之，如果2&gt;n，说明二叉树中不存在序号为2的结点，其左孩子不存在。同理，如果2×i+1=3≤n， 说明其右孩子存在且序号为3；如果3&gt;n，则二叉树中不存在序号为3的结点， 其右孩子不存在。</p><p>假设对于序号为j(1≤j≤i)的结点，当2×j≤n时，其左孩子存在且序号为2×j，当2×j&gt;n 时，其左孩子不存在；当2×j+1≤n时， 其右孩子存在且序号为2×j+1，当2×j+1&gt;n时，其右孩子不存在。 </p><p>当i=j+1时，根据完全二叉树的定义， 若其左孩子存在， 则其左孩子结点的序号一定等于序号为j的结点的右孩子的序号加1， 即其左孩子结点的序号等于 （2×j+1）+1=2（j+1）=2×i， 且有2×i≤n；如果2×i&gt;n， 则左孩子不存在。 若右孩子结点存在，则其右孩子结点的序号应等于其左孩子结点的序号加1，即右孩子结点的序号为2×i+1，且有2×i+1≤n；如果2×i+1&gt;n，则右孩子不存在。</p><p>故（2）和（3）得证。 </p><p>由（2）和（3）我们可以很容易证明（1）。 </p><p>当i=1时， 显然该结点为根结点，无双亲结点。当i&gt;1时，设序号为i的结点的双亲结点的序号为m，如果序号为i的结点是其双亲结点的左孩子，根据（2）有i=2×m，即m=i/2; 如果序号为i的结点是其双亲结点的右孩子，根据（3）有i=2×m+1， 即m=（i-1）/2=i/2-1/2，综合这两种情况，可以得到，当i&gt;1时， 其双亲结点的序号等于int(i/2)。</p><p>证毕。 </p><hr><h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><p>二叉树的结构是非线性的， 每一结点最多可有两个后继。</p><p>二叉树的存储结构有两种： 顺序存储结构和链式存储结构。 </p><h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><p><img src="https://s1.ax1x.com/2020/04/14/GxMdhQ.png" alt="" title="图4 二叉树与顺序存储结构"><br><img src="https://s1.ax1x.com/2020/04/14/GxMc7T.png" alt="" title="图5  单支二叉树与其顺序存储结构"></p><h3 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h3><p>对于任意的二叉树来说，每个结点最多只有两个孩子，一个双亲结点。我们可以设计每个结点至少包括三个域：数据域、 左孩子域和右孩子域：<br><img src="https://s1.ax1x.com/2020/04/14/Gx8xmR.jpg" alt=""><br>其中，LChild域指向该结点的左孩子，Data域记录该结点的信息，RChild域指向该结点的右孩子。 </p><p>用C++可以这样声明二叉树的二叉链表结点的结构：<br><img src="https://s1.ax1x.com/2020/04/15/J9CgEj.png" style="zoom:40%"><br>有时，为了便于找到父结点，可以增加一个Parent域， Parent域指向该结点的父结点。 该结点结构如下：<br><img src="https://s1.ax1x.com/2020/04/15/J9CbVJ.png" style="zoom:40%"></p><h4 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h4><p><img src="https://s1.ax1x.com/2020/04/15/J9PZxf.png" alt="" title="图6 二叉树和二叉链表"></p><h4 id="二叉树的性质6"><a href="#二叉树的性质6" class="headerlink" title="二叉树的性质6"></a>二叉树的性质6</h4><blockquote><p>若一个二叉树含有n个结点，则它的二叉链表中必含有2n个指针域， 其中必有n＋1个空的链域。</p></blockquote><h5 id="证明-5"><a href="#证明-5" class="headerlink" title="证明"></a>证明</h5><p>分支数目B=n-1，即非空的链域有n-1个，故空链域有2n-(n-1)=n+1个。</p><p>不同的存储结构实现二叉树的操作也不同。如要找某个结点的父结点，在三叉链表中很容易实现；在二叉链表中则需从根指针出发一一查找。可见，在具体应用中，需要根据二叉树的形态和需要进行的操作来决定二叉树的存储结构。 </p><hr><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p><img src="https://s1.ax1x.com/2020/04/15/J9iTAJ.png" style="zoom:40%"><br>我们用L、D、R分别表示遍历左子树、访问根结点、 遍历右子树， 那么对二叉树的遍历顺序就可以有六种方式： </p><ul><li>访问根，遍历左子树，遍历右子树（记做DLR）。 </li><li>访问根，遍历右子树，遍历左子树（记做DRL）。 </li><li>遍历左子树，访问根，遍历右子树（记做LDR）。 </li><li>遍历左子树，遍历右子树，访问根（记做LRD）。</li><li>遍历右子树，访问根，遍历左子树（记做RDL）。 </li><li>遍历右子树，遍历左子树，访问根（记做RLD）。 </li></ul><p>注意：先序、中序、后序遍历是递归定义的， 即在其子树中也按上述规律进行遍历。 </p><h3 id="先序遍历（DLR）"><a href="#先序遍历（DLR）" class="headerlink" title="先序遍历（DLR）"></a>先序遍历（DLR）</h3><p>若二叉树为空，则空操作，否则依次执行如下3个操作： </p><ul><li>访问根结点； </li><li>按先序遍历左子树； </li><li>按先序遍历右子树。 </li></ul><h3 id="中序遍历（LDR）"><a href="#中序遍历（LDR）" class="headerlink" title="中序遍历（LDR）"></a>中序遍历（LDR）</h3><p>若二叉树为空，则空操作，否则依次执行如下3个操作： </p><ul><li>按中序遍历左子树； </li><li>访问根结点； </li><li>按中序遍历右子树。</li></ul><h3 id="后序遍历（LRD）操作过程："><a href="#后序遍历（LRD）操作过程：" class="headerlink" title="后序遍历（LRD）操作过程："></a>后序遍历（LRD）操作过程：</h3><p>若二叉树为空，则空操作，否则依次执行如下3个操作： </p><ul><li>按后序遍历左子树；</li><li>按后序遍历右子树；</li><li>访问根结点。 </li></ul><hr><p><img src="https://s1.ax1x.com/2020/04/16/JFE1rn.png" alt=""><br>先序遍历：   A、 B、 D、 F、 G、 C、 E、 H 。 </p><p>中序遍历：   B、 F、 D、 G、 A、 C、 E、 H 。 </p><p>后序遍历：   F、 G、 D、 B、 H、 E、 C、 A 。 </p><p><img src="https://s1.ax1x.com/2020/04/16/JkWudO.png" alt=""></p><blockquote><p>最早提出遍历问题是对存储在计算机中的表达式求值。例如：（a+b*c）-d/e。该表达式用二叉树表示如图6.9所示。当我们对此二叉树进行先序、中序、后序遍历时，便可获得表达式的前缀、 中缀、 后缀书写形式： </p><p>前缀： -+a*bc/de </p><p>中缀： a+b*c-d/e </p><p>后缀： abc*+de/- </p><p>其中中缀形式是算术表达式的通常形式，只是没有括号。 前缀表达式称为波兰表达式。后缀表达式被称作逆波兰表达式。 在计算机内， 使用后缀表达式易于求值。 </p></blockquote><p><img src="https://s1.ax1x.com/2020/04/16/Jkfc3d.png" alt="" title="图9  算术式的二叉树表示 "></p><p>其中中缀形式是算术表达式的通常形式，只是没有括号。 前缀表达式称为波兰表达式。后缀表达式被称作逆波兰表达式。 在计算机内， 使用后缀表达式易于求值。 </p><p><strong>注意：</strong>通过一棵二叉树可以得到3种遍历次序，那编码可逆吗？也就是通过1种遍历次序能构造唯一的二叉树吗？答案肯定是不能的！而且通过2种遍历次序也不完全能构造唯一的二叉树(2种次序中必须要包含中序遍历才能构造唯一的二叉树)</p><p><a href="https://blog.csdn.net/yusiguyuan/article/details/42687623" target="_blank" rel="noopener">推荐博客</a></p><iframe src="https://blog.csdn.net/yusiguyuan/article/details/42687623" width="1200px" height="750px" frameborder="0" scrolling="yes"> </iframe><hr><h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><p>字典树、又称单词查找树，<a href="http://www.wutianqi.com/blog/1359.html" target="_blank" rel="noopener">Trie树</a>，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来节约存储空间，最大限度地减少无谓的字符串比较，查询效率比哈希表高。</p><p>字典树与字典很相似，当你要查一个单词是不是在字典树中，首先看单词的第一个字母是不是在字典的第一层，如果不在，说明字典树里没有该单词，如果有就在该字母的孩子节点里找是不是有单词的第二个字母，没有就说明没有该单词，有的话用同样的方法继续查找。字典树不仅可以用来储存字母，也可以储存数字等其它数据。</p><p><img src="https://s1.ax1x.com/2020/04/16/Jk55E6.jpg" alt="" title="字典树"></p><hr><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p>线段树（Segment Tree）是一种二叉搜索树，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。</p><p>对于线段树中的每一个非叶子结点[a,b]，它的左子树表示的区间为[a,(a+b)/2]，右子树表示的区间为[(a+b)/2+1,b]。因此线段树是平衡二叉树。叶结点数目为N，即整个线段区间的长度。</p><p>使用线段树可以快速的查找某一个结点在若干条线段中出现的次数，时间复杂度为O(logN)。而未优化的空间复杂度为2N，因此有时需要离散化让空间压缩。</p><p><img src="https://s1.ax1x.com/2020/04/16/JkIZV0.png" alt="" title="线段树"></p><hr><h2 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h2><p>平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><p><img src="https://s1.ax1x.com/2020/04/16/JkIRJS.jpg" alt="" title="平衡二叉搜索树"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/04/12/GqWaTg.png&quot; alt title=&quot;图1 树&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;上物，谓之树焉&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://liu-zhou-l.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="树" scheme="https://liu-zhou-l.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>4月5日综合测试</title>
    <link href="https://liu-zhou-l.github.io/posts/20077c63/"/>
    <id>https://liu-zhou-l.github.io/posts/20077c63/</id>
    <published>2020-04-05T00:17:00.000Z</published>
    <updated>2023-09-21T08:20:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="神奇的队伍"><a href="#神奇的队伍" class="headerlink" title="神奇的队伍"></a>神奇的队伍</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>你知道吗，在重庆市第八中学校中，流传着四大不可思议的传说。接下来，你将看到四大不可思议之一——神奇的队伍。</p><p>相传在八中科技楼的五楼和六楼之间的楼梯的第七步台阶的旁边墙壁上，存在一个隐藏的空间，这个空间中存在着一支神奇的队伍，一支由名为ぎさう的怪异组成的队伍。他们性格散漫，整天以捣蛋搞恶作剧为生，这不，他们又准备出发啦！当然，在他们出发捣乱之前，肯定要先一个一个的排好队，所有的ぎさう一共需要排成n列，当带头的ぎさう喊出稍息的之后，由于这些ぎさう散漫惯了，有迈左腿的，也有迈右腿的，很不整齐。已知在第i列中，有li个ぎさう先迈出了左腿，有ri个ぎさう迈出了右腿。假设所有的ぎさう中，有L个ぎさう迈出左腿，R个ぎさう迈出右腿时，整个队伍的整齐度为|L-R|，现在，带头的ぎさう希望能改变一整列的ぎさう的动作，使得这一列的所有ぎさう之前迈出左腿的现在迈右腿，之前迈右腿的现在迈左腿（当然也可以不改变）。现在带头的ぎさう需要计算，他需要改变哪一列，才能使整个队伍的整齐度最大。如果不改变任何一列，则输出0.</p></blockquote><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><blockquote><p>第一行一个数字n（1≤n≤100000），表示ぎさう所拥有的列数。</p><p>接下来n行，每行两个数字l_i和r_i（1≤l_i，r_i≤500），表示这一列的ぎさう迈出左腿的数量和迈出右腿的数量。</p></blockquote><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><blockquote><p>一个数字，表示需要改变的第几列。如果不需要改变任何一列的动作，则输出0。</p></blockquote><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入："><a href="#样例输入：" class="headerlink" title="样例输入："></a>样例输入：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">6 5</span><br><span class="line">5 6</span><br></pre></td></tr></table></figure><h3 id="样例输出："><a href="#样例输出：" class="headerlink" title="样例输出："></a>样例输出：</h3><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure></h2><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><blockquote><p>暴力可解此题</p></blockquote><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, l[MAXN], r[MAXN], totl = <span class="number">0</span>, totr = <span class="number">0</span>, ans = <span class="number">0</span>, minn;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n; i ++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;l[i], &amp;r[i]);</span><br><span class="line">totl += l[i];</span><br><span class="line">totr += r[i];</span><br><span class="line">&#125;</span><br><span class="line">minn = <span class="built_in">fabs</span>(totl - totr);</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n; i ++) &#123;</span><br><span class="line">temp = <span class="built_in">fabs</span>(totl - l[i] + r[i] - totr + r[i] - l[i]);</span><br><span class="line"><span class="keyword">if</span>(temp &gt; minn) &#123;</span><br><span class="line">ans = i;</span><br><span class="line">minn = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h1 id="神奇的数"><a href="#神奇的数" class="headerlink" title="神奇的数"></a>神奇的数</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>你知道吗，在重庆市第八中学校中，流传着四大不可思议的传说。接下来，你将看到四大不可思议之二——神奇的数。</p><p>相传在八中初一的数学课上，每当数学老师们在黑板上板书了一长串的数字时，这个神奇的数字就会冷不丁的冒出来，他会将数学老师们板书的数字全部对这个神奇的数取模，然后大家会惊奇的发现，老师板书的数字全部对神奇的数取模后，得到了同一个数字。</p><p>现在告诉你老师书写在黑板上的数字的个数以及所有老师写的数字，请你求出所有的可能的神奇的数的值。</p></blockquote><h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><blockquote><p>第一行一个数字n（1≤n≤100），表示老师书写的数字个数。</p><p>接下来n行，每行一个数字a_i（1≤a_i≤10^14），表示老师书写的每一个数字分别的值。</p></blockquote><h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><blockquote><p>若干个数字，表示神奇的数的所有可能的值，中间用一个空格隔开。</p></blockquote><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入：-1"><a href="#样例输入：-1" class="headerlink" title="样例输入："></a>样例输入：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">6</span><br><span class="line">34</span><br><span class="line">38</span><br></pre></td></tr></table></figure><h3 id="样例输出：-1"><a href="#样例输出：-1" class="headerlink" title="样例输出："></a>样例输出：</h3><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 4</span><br></pre></td></tr></table></figure></h2><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>第一反应肯定是暴力啦ヽ(￣▽￣)ﾉ <del>被无情地TLE</del></p><p>咳，暴力不行？那来分析一下题目，所要求的数为为所有元素的 <strong>同余模数</strong> 因此，我们可以用到一个数学结论：</p><blockquote><p>如果有两个整数a、b ，它们除以m所得的余数相等，则a与b的差能被m整除。也就是说，a-b（a≥b）就是最大的m。</p></blockquote><p>而在此题中，最大的m为最小的<strong>abs（a[i]-a[j]）的值</strong>（想一想为什么是最小的哦），可以用循环来求。还要考虑一个问题，此题的输入可能会有重复元素，所以在输入时还要进行去重。</p><p>m为满足条件的最大同余模数，然后呢，m的因数也有可能是符合题意的，所以还要求出m的所有因数，再进行判断，符合条件就输出</p><h2 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h2><h2 id="-3"><a href="#-3" class="headerlink" title=""></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">105</span>;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;, greater&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; &gt; que;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, len;<span class="comment">//len为数组去重后的元素个数</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[MAXN], minn;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> temp;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;temp);</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= len; k ++) &#123;</span><br><span class="line"><span class="keyword">if</span>(a[k] == temp) &#123;<span class="comment">//如果temp出现过，flag设为0，跳出循环</span></span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) &#123;<span class="comment">//没有出现过，则加入集合</span></span><br><span class="line">a[++ len] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(len == <span class="number">1</span>) &#123;<span class="comment">//当长度为1时，直接输出其元素的所有非1因数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">2</span>; i &lt;= a[<span class="number">1</span>]; i ++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld "</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">sort(a + <span class="number">1</span>, a + <span class="number">1</span> + len);<span class="comment">//因为要求最小的fabs(a[i] - a[i - 1])，所以对其进行排序</span></span><br><span class="line">minn = <span class="number">1e14</span> + <span class="number">5</span>;/最大的m</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">fabs</span>(a[i] - a[i - <span class="number">1</span>]) &lt; minn) minn = <span class="built_in">fabs</span>(a[i] - a[i - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(minn &gt; <span class="number">1</span>) que.push(minn);<span class="comment">//如果minn非1，则入队</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= minn; i ++) &#123;<span class="comment">//循环m的因数</span></span><br><span class="line"><span class="keyword">if</span>(minn % i == <span class="number">0</span>) &#123;</span><br><span class="line">que.push(i);<span class="comment">//符合条件即入队</span></span><br><span class="line"><span class="keyword">if</span>(minn / i != i) &#123;<span class="comment">//非平方数，则将minn / i也入队</span></span><br><span class="line">que.push(minn / i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!que.empty()) &#123;</span><br><span class="line">temp = que.top();</span><br><span class="line">que.pop();</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> last = a[<span class="number">1</span>] % temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span>(a[i] % temp != last) &#123;<span class="comment">//如果a[i] % temp != a[i - 1] % temp，falg设为0，跳出循环</span></span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld "</span>, temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h1 id="神奇的通道"><a href="#神奇的通道" class="headerlink" title="神奇的通道"></a>神奇的通道</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>你知道吗，在重庆市第八中学校中，流传着四大不可思议的传说。接下来，你将看到四大不可思议之三——神奇的通道。</p><p>相传在八中科技楼的六楼和七楼之间，存在一条秘密通道，在这条通道内，挂满了各种各样神奇的画。而这条通道，是由n条长度不一的小通道构成。以你进入这条通道的起点为0点，如果可以从占用区间(a,b)的小通道移动到占用区间(c,d)的小通道去，那么，当且仅当c&lt;a&lt;d或c&lt;b&lt;d时成立。</p><p>接下来，你的程序会处理一下两种类型的查询：</p><p>1、“1 x y”，表示添加一条新的小通道(x,y)到整个通道中。新的通道的长度总是大于前面已有的所有小通道。</p><p>2、“2 a b”，请你回答，在当前已有的小通道中，第a条小通道能否到达第b条小通道。</p><p>注意：所有添加的小通道的范围均为开区间，且最初始秘密通道内没有小通道存在。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;神奇的队伍&quot;&gt;&lt;a href=&quot;#神奇的队伍&quot; class=&quot;headerlink&quot; title=&quot;神奇的队伍&quot;&gt;&lt;/a&gt;神奇的队伍&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;你知道吗，在重庆市第八中学校中，流传着四大不可思议的传说。接下来，你将看到四大不可思议之一——神奇的队伍。&lt;/p&gt;
&lt;p&gt;相传在八中科技楼的五楼和六楼之间的楼梯的第七步台阶的旁边墙壁上，存在一个隐藏的空间，这个空间中存在着一支神奇的队伍，一支由名为ぎさう的怪异组成的队伍。他们性格散漫，整天以捣蛋搞恶作剧为生，这不，他们又准备出发啦！当然，在他们出发捣乱之前，肯定要先一个一个的排好队，所有的ぎさう一共需要排成n列，当带头的ぎさう喊出稍息的之后，由于这些ぎさう散漫惯了，有迈左腿的，也有迈右腿的，很不整齐。已知在第i列中，有li个ぎさう先迈出了左腿，有ri个ぎさう迈出了右腿。假设所有的ぎさう中，有L个ぎさう迈出左腿，R个ぎさう迈出右腿时，整个队伍的整齐度为|L-R|，现在，带头的ぎさう希望能改变一整列的ぎさう的动作，使得这一列的所有ぎさう之前迈出左腿的现在迈右腿，之前迈右腿的现在迈左腿（当然也可以不改变）。现在带头的ぎさう需要计算，他需要改变哪一列，才能使整个队伍的整齐度最大。如果不改变任何一列，则输出0.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入格式&quot; class=&quot;headerlink&quot; title=&quot;输入格式&quot;&gt;&lt;/a&gt;输入格式&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;第一行一个数字n（1≤n≤100000），表示ぎさう所拥有的列数。&lt;/p&gt;
&lt;p&gt;接下来n行，每行两个数字l_i和r_i（1≤l_i，r_i≤500），表示这一列的ぎさう迈出左腿的数量和迈出右腿的数量。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="测试" scheme="https://liu-zhou-l.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://liu-zhou-l.github.io/posts/4a17b156/"/>
    <id>https://liu-zhou-l.github.io/posts/4a17b156/</id>
    <published>2020-04-02T00:36:00.000Z</published>
    <updated>2023-09-21T08:20:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
